<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://joohunhyun.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://joohunhyun.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-17T03:48:09+00:00</updated><id>https://joohunhyun.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">(ENG) MLP, DNN</title><link href="https://joohunhyun.github.io/blog/2024/skip-safety-skip/" rel="alternate" type="text/html" title="(ENG) MLP, DNN"/><published>2024-12-17T00:00:00+00:00</published><updated>2024-12-17T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/skip-safety-skip</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/skip-safety-skip/"><![CDATA[<ul> <li>Perceptron -&gt; delta rule</li> <li>MLP (2~3 layers) -&gt; backpropagation</li> <li>DNN (~10 layers) -&gt; using ReLU instead of sigmoid</li> </ul> <h4 id="mlps-problem">MLP’s problem</h4> <ul> <li>Major issue of designing MLP is how</li> <li>As the number of hidden layers increase, the sigmoid function’s relatively small gradient repeatedly gets multiplied. -&gt; this makes the gradient close to 0, and the weights are not updated (<strong>vanishing gradient problem</strong>)</li> </ul> <p><strong>Solution to this problem</strong></p> <ol> <li>Using a ReLU Function</li> </ol> <p>The Rectified Linear Unit (ReLU) function is defined as:</p> \[f(x)=max(0,x)\] <p>ReLU has a gradient of 1 1 for positive inputs, which prevents the gradient from shrinking excessively as it is propagated through the network.</p> <p>Advantages of ReLU:</p> <ul> <li>Avoids vanishing gradients: The gradient remains constant for positive inputs, ensuring that weights continue to be updated.</li> <li>Computational efficiency: ReLU is simpler to compute than sigmoid or tanh.</li> <li>Sparsity: It introduces sparsity in activations (many outputs are zero), which can improve generalization.</li> </ul> <p>However, ReLU can suffer from the dying ReLU problem, where neurons become inactive (outputting zero) due to large negative gradients. Variants like Leaky ReLU and Parametric ReLU address this issue.</p> <ol> <li>Xavier Initialization</li> </ol> <p>Proper weight initialization is crucial for mitigating vanishing or exploding gradients. The Xavier initialization (or Glorot initialization) ensures that the variance of activations and gradients is maintained across layers.</p> <p>Benefits:</p> <ul> <li>Prevents vanishing/exploding gradients by keeping the variance of inputs and outputs consistent across layers.</li> <li>Helps the network converge faster.</li> </ul> <ol> <li>Batch Normalization</li> </ol> <p>Batch Normalization (BatchNorm) normalizes the inputs to each layer by adjusting the mean and variance of the activations during training.</p> <p>Benefits</p> <ul> <li>Improves gradient flow: Normalization reduces internal covariate shift, allowing deeper networks to train effectively.</li> <li>Stabilizes learning: It reduces sensitivity to initialization and learning rate.</li> <li>Acts as regularization: BatchNorm has a slight regularization effect, reducing the need for dropout in some cases.</li> </ul>]]></content><author><name></name></author><category term="study"/><category term="ML"/><summary type="html"><![CDATA[Perceptron -&gt; delta rule MLP (2~3 layers) -&gt; backpropagation DNN (~10 layers) -&gt; using ReLU instead of sigmoid]]></summary></entry><entry><title type="html">(ENG) SVM, SVC</title><link href="https://joohunhyun.github.io/blog/2024/machine-learning-copy/" rel="alternate" type="text/html" title="(ENG) SVM, SVC"/><published>2024-12-16T00:00:00+00:00</published><updated>2024-12-16T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/machine-learning%20copy</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/machine-learning-copy/"><![CDATA[<p><strong>Table of Contents</strong></p> <hr/> <h4 id="classification-models">Classification Models</h4> <p>Definition : 두개의 class A and B를 feature space에서 분리하는 모델</p> <ul> <li>Decision Trees</li> <li>Probabilistic models</li> <li>Linear models</li> <li>Non-linear models</li> </ul> <p>In the case of non-linear data, there are different methods to model this.</p> <ol> <li>MLP : achieve non-linearlity by combining perceptrons(linear models)</li> <li>SVM : supervised machine learning algorithm used for classification and regression tasks.</li> <li>SVC :</li> </ol> <h5 id="svm">SVM</h5> <p>Support Vector Machine (SVM) is a supervised machine learning algorithm used for classification and regression tasks. The key idea is to find the best hyperplane that separates data points into different classes. In an ideal case, this hyperplane maximizes the margin between data points of different classes.</p> <ul> <li>Core Concepts: <ul> <li>The hyperplane is the decision boundary.</li> <li>SVM focuses on data points (support vectors) near the decision boundary that influence its position.</li> <li>The algorithm uses kernels to transform data into higher-dimensional spaces when it is not linearly separable in the original space.</li> </ul> </li> <li>Applications: Image classification, text categorization, and other binary/multi-class problems.</li> <li>Pros: <ul> <li>Effective for high-dimensional spaces.</li> <li>Works well with a clear margin of separation.</li> </ul> </li> <li>Cons: <ul> <li>Computationally expensive for large datasets.</li> <li>Sensitive to the choice of kernel and hyperparameters.</li> </ul> </li> </ul> <h6 id="rbf-kernel">RBF Kernel</h6> <p>The RBF kernel, also known as the Gaussian kernel, is one of the most commonly used kernels in SVM. It is a non-linear kernel that maps data points into a higher-dimensional space where a linear hyperplane can effectively separate them.</p> <p>Characteristics:</p> <ul> <li>Non-linearity: It can model complex relationships in the data.</li> <li>Local influence: Points that are closer to each other have a higher similarity, and their influence decreases exponentially with distance</li> <li> <p>Scalability: Effective for problems where the decision boundary is not linear.</p> </li> <li>Pros: <ul> <li>Handles non-linearly separable data well.</li> <li>Requires fewer hyperparameters compared to other kernels.</li> </ul> </li> <li>Cons: <ul> <li>γ must be carefully tuned; poor tuning can lead to overfitting or underfitting.</li> </ul> </li> </ul> <h6 id="polynomial-kernel">Polynomial Kernel</h6> <p>The Polynomial kernel is another non-linear kernel used in SVM. It computes the similarity between two data points as a polynomial function of their inner product in the input space.</p> <p>Characteristics:</p> <ul> <li>Non-linearity: Maps the input space to a higher-dimensional space defined by polynomial terms.</li> <li>Flexibility: The degree \(d\) controls the complexity of the decision boundary.</li> <li>Global influence: Unlike the RBF kernel, it considers global features of the data.</li> <li>Pros: <ul> <li>Can model non-linear relationships with adjustable complexity via \(d\)</li> <li>Effective for datasets where classes are distinguishable by polynomial decision boundaries.</li> </ul> </li> <li>Cons: <ul> <li>More sensitive to feature scaling than the RBF kernel.</li> <li>Higher degrees can lead to overfitting.</li> </ul> </li> </ul> <h5 id="svc">SVC</h5> <ul> <li> <p>SVC stands for Support Vector Classifier and is the implementation of SVM for classification tasks in libraries like scikit-learn.</p> </li> <li>Key Differences Between SVM and SVC: SVM is the broader concept that encompasses both classification and regression tasks (e.g., SVM for regression is called SVR).</li> <li>SVC is specifically the classification implementation of SVM in scikit-learn.</li> <li>Features of SVC: <ul> <li>It supports linear and non-linear kernels like polynomial, RBF (Radial Basis Function), and sigmoid.</li> <li>Provides hyperparameters like C (regularization strength) and gamma (kernel coefficient) for tuning the model.</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="study"/><category term="ML"/><summary type="html"><![CDATA[Table of Contents]]></summary></entry><entry><title type="html">(ENG) Feature Selection, Extraction, and Ensamble Methods</title><link href="https://joohunhyun.github.io/blog/2024/machine-learning/" rel="alternate" type="text/html" title="(ENG) Feature Selection, Extraction, and Ensamble Methods"/><published>2024-12-16T00:00:00+00:00</published><updated>2024-12-16T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/machine-learning</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/machine-learning/"><![CDATA[<p><strong>Table of Contents</strong></p> <hr/> <h4 id="feature-subset-selection">Feature Subset Selection</h4> <p>Definition : Feature subset selection finds a subset of original features without new features</p> <h5 id="1-filter-method">1. Filter Method</h5> <ul> <li>Evaluates features with performance measures based on information gain or distance between each attribute in the class</li> <li>장점 : computationally siple and fast</li> <li>단점 : slow searching</li> <li>해결책 : use a single-attribute evaluator with ranking</li> </ul> <h5 id="2-wrapper-method">2. Wrapper Method</h5> <ul> <li>Searches for best combination of features among <strong>all</strong> posttible combination</li> <li>장점 : generally better performance, simple and direct</li> <li>단점 : \(O(n^2)\) time complexity - slow</li> <li>해결책 <ul> <li>eliminate irrelevant features</li> <li>eliminate redundant attributes</li> </ul> </li> </ul> <h5 id="3-embedded-method">3. Embedded method</h5> <ul> <li>Uses ML models for classification and then an obtimal subset of features/ranking of feature is built by the classifier algorithm</li> </ul> <h5 id="search-methods">Search Methods</h5> <ul> <li>Weka 예제에서는 classfier(wrapper, etc)와 search method 둘 다 정의해야한다.</li> </ul> <h5 id="different-search-methods">Different Search Methods</h5> <ol> <li>Exhaustive : \(2^n\) subsets</li> <li>Backwards</li> <li>Forwards</li> <li>Bidirectional</li> </ol> <h2><br/></h2> <h4 id="feature-extraction-aka-reducing-dimentionality">Feature Extraction (AKA: Reducing Dimentionality)</h4> <p>Definition : extracts new set of features from the original features</p> <h5 id="pca">PCA</h5> <ul> <li>Definition : unsupervised approach to examine relations among a set of variables</li> <li>When to use this? <ul> <li>PCA is useful in reducing the dimentionality of 3-D, 4-D scatterplots (왜 사용하냐 : visually difficult to interpret data points in high-dimensional space)</li> </ul> </li> <li>Ex : Compressing MNIST- dataset using PCA (to reduce dimension)</li> </ul> <h2 id="-1"><br/></h2> <h4 id="ensamble-method">Ensamble Method</h4> <ul> <li>Definition : 여러개의 모델들을 조합해서 더욱 정확한 결정을 내리는 방법 (위원회 운영과 비슷)</li> </ul> <p>Types of Ensamble Methods:</p> <ol> <li>Boosting</li> <li>Bagging</li> <li>Stacking</li> </ol> <h5 id="1-boosting-ada-boosting">1. Boosting :Ada-Boosting</h5> <h5 id="2-baggingstands-for-boostrap-aggrevating">2. Bagging(stands for: Boostrap Aggrevating)</h5> <p>Bagging은 앙상블 기법들 가운데 가장 간단한 방법이다(taking a vote, or weighted vote). Decision Tree의 경우, training set에 따라서 그 구조가 매우 민감하게 바뀐다. 이런 경우에는 1) training set을 여러 개 만들고 2) 각각 모델을 만들어서 3) voting을 한다. In numerical prediction, taking the average of all predictions.</p> <p>Breiman(1996) noticed that an ensamble of trees improved when the trees differed significantly from each other, today called <strong>Random Forest</strong>. Bagging was able to create a diverse ensamble of classifiers by introducing randomness into the learning alg’s input, which resulted in <strong>better results</strong>. In a DT, picking the best option can be randomized by picking one of the N best options at random instead of a signle winner (ex: top 3 options, top 5 options)</p> <p><strong>Methods of picking different “winners” in bagging</strong></p> <ol> <li>elite : picking the best one</li> <li>randomization : picking 1 randomly from top 5 candidates</li> <li>stochastic : top5 중에서 룰렛으로 고르는 방법 (weighted)</li> </ol> <h5 id="3-stacking">3. Stacking</h5> <p>Stacking is used on models built by different learning algorithsm. For example, stacking can be used when you want to form a classifier for a given dataset with A) deicision tree inducer B) naive bayes learnner and C) instance based learning scheme.</p> <p>Stacking involves a <strong>metalearner</strong> that replaces the voting procedure of boosing and bagging. Metalearner is used to discover how to best combine the output of the base learners to determine which classifiers are the reliable ones.</p> <ul> <li>base learners : level-0 models</li> <li>meta learner : level-1 model</li> <li>predictions from base models are inputs to the meta learner. (funnel처럼 위에서 아래로 내려온다)</li> </ul> <p>TL;DR : Stacking combines predictions of base learners using metalearner(NOT voting)</p>]]></content><author><name></name></author><category term="study"/><category term="ML"/><summary type="html"><![CDATA[Table of Contents]]></summary></entry><entry><title type="html">(KOR) 연구실 안전교육 배속하는 방법</title><link href="https://joohunhyun.github.io/blog/2024/skip-safety-skip-copy/" rel="alternate" type="text/html" title="(KOR) 연구실 안전교육 배속하는 방법"/><published>2024-12-16T00:00:00+00:00</published><updated>2024-12-16T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/skip-safety-skip%20copy</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/skip-safety-skip-copy/"><![CDATA[<p>202412월 기준, 해당 방법이 가장 편하다. 다른 방법들은 모두 막혔다. 중간에 “깜짝 퀴즈”도 있으니 유의해야한다.</p> <p><strong>크롬</strong>에서 연구실 안전교육 동영상 재생 후 개발자모드 콘솔 <code class="language-plaintext highlighter-rouge">F12</code>에 해당 코드 붙여넣기:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>document.querySelector('video').playbackRate = 15;
</code></pre></div></div>]]></content><author><name></name></author><category term="study"/><category term="tools"/><summary type="html"><![CDATA[202412월 기준, 해당 방법이 가장 편하다. 다른 방법들은 모두 막혔다. 중간에 “깜짝 퀴즈”도 있으니 유의해야한다.]]></summary></entry><entry><title type="html">(ENG) VsCode Shortcut Keys(MacOS)</title><link href="https://joohunhyun.github.io/blog/2024/VsCode-Shortcut-Keys/" rel="alternate" type="text/html" title="(ENG) VsCode Shortcut Keys(MacOS)"/><published>2024-12-13T00:00:00+00:00</published><updated>2024-12-13T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/VsCode-Shortcut-Keys</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/VsCode-Shortcut-Keys/"><![CDATA[<p>💡익숙해진 단축키는 문서에서 삭제</p> <p>💡원본은 .md 파일에 존안</p> <hr/> <p><strong>Table of contents</strong></p> <ul> <li><a href="#vscode-shortcuts">VScode Shortcuts</a></li> <li><a href="#vscode-git-status">VSCode git status</a></li> </ul> <p><br/></p> <h4 id="vscode-shortcuts">VScode Shortcuts</h4> <table> <thead> <tr> <th>Action</th> <th>Shortcut</th> </tr> </thead> <tbody> <tr> <td><strong>General</strong></td> <td> </td> </tr> <tr> <td>Open Command Palette</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + P</code></td> </tr> <tr> <td>Open Settings</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ,</code></td> </tr> <tr> <td>Open Keyboard Shortcuts</td> <td><code class="language-plaintext highlighter-rouge">⌘ + K ⌘ + S</code></td> </tr> <tr> <td>Open Extensions View</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + X</code></td> </tr> <tr> <td>Show Integrated Terminal</td> <td><code class="language-plaintext highlighter-rouge">⌃ + \</code></td> </tr> <tr> <td>Close Window</td> <td><code class="language-plaintext highlighter-rouge">⌘ + W</code></td> </tr> <tr> <td>Quit VSCode</td> <td><code class="language-plaintext highlighter-rouge">⌘ + Q</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>GitHub Copilot</strong></td> <td> </td> </tr> <tr> <td>Accept Suggestion</td> <td><code class="language-plaintext highlighter-rouge">Tab</code></td> </tr> <tr> <td>Next Suggestion</td> <td><code class="language-plaintext highlighter-rouge">Option(Alt) + ]</code></td> </tr> <tr> <td>Previous Suggestion</td> <td><code class="language-plaintext highlighter-rouge">Option(Alt) + [</code></td> </tr> <tr> <td>Show Suggestions</td> <td><code class="language-plaintext highlighter-rouge">Ctrl + Enter</code></td> </tr> <tr> <td>Approve Suggestion</td> <td><code class="language-plaintext highlighter-rouge">Cmd + ←</code> or <code class="language-plaintext highlighter-rouge">Cmd + →</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>File Management</strong></td> <td> </td> </tr> <tr> <td>Open File</td> <td><code class="language-plaintext highlighter-rouge">⌘ + O</code></td> </tr> <tr> <td>Save File</td> <td><code class="language-plaintext highlighter-rouge">⌘ + S</code></td> </tr> <tr> <td>Save All Files</td> <td><code class="language-plaintext highlighter-rouge">⌥ + ⌘ + S</code></td> </tr> <tr> <td>Close Editor</td> <td><code class="language-plaintext highlighter-rouge">⌘ + W</code></td> </tr> <tr> <td>Reopen Closed Editor</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + T</code></td> </tr> <tr> <td>New File</td> <td><code class="language-plaintext highlighter-rouge">⌘ + N</code></td> </tr> <tr> <td>Open Recent Files</td> <td><code class="language-plaintext highlighter-rouge">⌘ + R</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Editing</strong></td> <td> </td> </tr> <tr> <td>Cut Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + X</code></td> </tr> <tr> <td>Copy Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + C</code></td> </tr> <tr> <td>Paste</td> <td><code class="language-plaintext highlighter-rouge">⌘ + V</code></td> </tr> <tr> <td>Delete Line</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + K</code></td> </tr> <tr> <td>Duplicate Line</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌥ + ↓</code> or <code class="language-plaintext highlighter-rouge">⇧ + ⌥ + ↑</code></td> </tr> <tr> <td>Move Line Up/Down</td> <td><code class="language-plaintext highlighter-rouge">⌥ + ↑</code> or <code class="language-plaintext highlighter-rouge">⌥ + ↓</code></td> </tr> <tr> <td>Indent Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ]</code></td> </tr> <tr> <td>Outdent Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + [</code></td> </tr> <tr> <td>Comment Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + /</code></td> </tr> <tr> <td>Add Multi-Cursor</td> <td><code class="language-plaintext highlighter-rouge">⌥ + Click</code></td> </tr> <tr> <td>Select All Occurrences</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ⇧ + L</code></td> </tr> <tr> <td>Expand Selection</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌥ + →</code></td> </tr> <tr> <td>Shrink Selection</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌥ + ←</code></td> </tr> <tr> <td>Format Document</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌥ + F</code></td> </tr> <tr> <td>Go to Matching Bracket</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + \</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Navigation</strong></td> <td> </td> </tr> <tr> <td>Go to File</td> <td><code class="language-plaintext highlighter-rouge">⌘ + P</code></td> </tr> <tr> <td>Go to Line</td> <td><code class="language-plaintext highlighter-rouge">⌃ + G</code></td> </tr> <tr> <td>Go to Definition</td> <td><code class="language-plaintext highlighter-rouge">F12</code></td> </tr> <tr> <td>Go to Implementation</td> <td><code class="language-plaintext highlighter-rouge">⌘ + F12</code></td> </tr> <tr> <td>Show References</td> <td><code class="language-plaintext highlighter-rouge">⇧ + F12</code></td> </tr> <tr> <td>Navigate Back</td> <td><code class="language-plaintext highlighter-rouge">⌃ + -</code></td> </tr> <tr> <td>Navigate Forward</td> <td><code class="language-plaintext highlighter-rouge">⌃ + ⇧ + -</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Search and Replace</strong></td> <td> </td> </tr> <tr> <td>Find</td> <td><code class="language-plaintext highlighter-rouge">⌘ + F</code></td> </tr> <tr> <td>Find in Files</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + F</code></td> </tr> <tr> <td>Replace</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ⌥ + F</code></td> </tr> <tr> <td>Replace in Files</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + H</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Debugging</strong></td> <td> </td> </tr> <tr> <td>Start/Continue Debugging</td> <td><code class="language-plaintext highlighter-rouge">F5</code></td> </tr> <tr> <td>Step Over</td> <td><code class="language-plaintext highlighter-rouge">F10</code></td> </tr> <tr> <td>Step Into</td> <td><code class="language-plaintext highlighter-rouge">F11</code></td> </tr> <tr> <td>Step Out</td> <td><code class="language-plaintext highlighter-rouge">⇧ + F11</code></td> </tr> <tr> <td>Restart Debugging</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + F5</code></td> </tr> <tr> <td>Stop Debugging</td> <td><code class="language-plaintext highlighter-rouge">⇧ + F5</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Terminal</strong></td> <td> </td> </tr> <tr> <td>Create New Terminal</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ⇧ + </code>`</td> </tr> <tr> <td>Split Terminal</td> <td><code class="language-plaintext highlighter-rouge">⌘ + \</code>`</td> </tr> <tr> <td>Kill Terminal</td> <td><code class="language-plaintext highlighter-rouge">⌘ + K</code> (inside terminal)</td> </tr> <tr> <td>Navigate Terminals</td> <td><code class="language-plaintext highlighter-rouge">⌃ + ←</code> or <code class="language-plaintext highlighter-rouge">⌃ + →</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Version Control</strong></td> <td> </td> </tr> <tr> <td>Open Source Control</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + G</code></td> </tr> <tr> <td>Commit Changes</td> <td><code class="language-plaintext highlighter-rouge">⌘ + Enter</code> (in source control)</td> </tr> </tbody> </table> <p><br/></p> <h4 id="vscode-git-status">VSCode git status</h4> <table> <thead> <tr> <th>Code</th> <th>Status</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>A</td> <td>Added</td> <td>This is a new file that has been added to the repository</td> </tr> <tr> <td>M</td> <td>Modified</td> <td>An existing file has been changed</td> </tr> <tr> <td>D</td> <td>Deleted</td> <td>A file has been deleted</td> </tr> <tr> <td>U</td> <td>Untracked</td> <td>The file is new or has been changed but has not been added to the repository yet</td> </tr> <tr> <td>C</td> <td>Conflict</td> <td>There is a conflict in the file</td> </tr> <tr> <td>R</td> <td>Renamed</td> <td>The file has been renamed</td> </tr> <tr> <td>S</td> <td>Submodule</td> <td>In repository exists another subrepository</td> </tr> <tr> <td>T</td> <td>Typechange</td> <td>The file changed from symlink to regular file, or vice versa</td> </tr> </tbody> </table> ]]></content><author><name></name></author><category term="study"/><category term="tools"/><summary type="html"><![CDATA[💡익숙해진 단축키는 문서에서 삭제]]></summary></entry><entry><title type="html">(ENG) Brief History of AI</title><link href="https://joohunhyun.github.io/blog/2024/history-of-ML/" rel="alternate" type="text/html" title="(ENG) Brief History of AI"/><published>2024-12-13T00:00:00+00:00</published><updated>2024-12-13T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/history-of-ML</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/history-of-ML/"><![CDATA[<p><strong>Table of Contents</strong></p> <ul> <li><a href="#1940s1950s---early-foundations">1940s–1950s - Early Foundations</a></li> <li><a href="#1950s1960s---discovery-of-neural-networks">1950s–1960s - Discovery of Neural Networks</a></li> <li><a href="#1970s1980s---ais-first-winter인공지능의-첫-겨울--backpropagation역전파기법">1970s–1980s - AI’s First Winter(인공지능의 첫 겨울) \&amp; Backpropagation(역전파기법)</a></li> <li><a href="#1980s1990s---sequence-processing-and-memory">1980s–1990s - Sequence Processing and Memory</a></li> <li><a href="#1997---long-short-term-memorylstm-hochreiter--schmidhuber">1997 - Long Short-Term Memory(LSTM) (Hochreiter \&amp; Schmidhuber)</a></li> <li><a href="#1980s1990s---visual-recognition-and-spatial-data">1980s–1990s - Visual Recognition and Spatial Data</a></li> <li><a href="#2012---deep-learning-revolution">2012 - Deep Learning Revolution</a></li> <li><a href="#2014---generative-adversarial-networksgan-goodfellow">2014 - Generative Adversarial Networks(GAN) (Goodfellow)</a></li> <li><a href="#2017---attention-mechanisms-and-transformers-vaswani-et-al">2017 - Attention Mechanisms and Transformers (Vaswani et al.)</a></li> <li><a href="#2020s---multi-modal-ai-and-real-time-applications">2020s - Multi-Modal AI and Real-Time Applications</a></li> <li><a href="#tldr">TL;DR</a></li> </ul> <hr/> <h4 id="1940s1950s---early-foundations">1940s–1950s - Early Foundations</h4> <p>Discovery: Boolean logic and the Turing Test</p> <p>Problem: How can we formalize reasoning and test machine intelligence?</p> <p>Solution: Alan Turing introduced the concept of a machine capable of computation (Turing Machine) and proposed the Turing Test as a way to determine if a machine exhibits intelligent behavior.</p> <p><br/></p> <h4 id="1950s1960s---discovery-of-neural-networks">1950s–1960s - Discovery of Neural Networks</h4> <p>Discovery: Perceptron (1958, Frank Rosenblatt)</p> <p>Problem: How can we mimic the human brain’s ability to learn patterns?</p> <p>Solution: The perceptron, a simple single-layer neural network, was developed to classify data linearly by adjusting weights using feedback. However, it was unable to solve non-linear problems, such as XOR.</p> <p><br/></p> <h4 id="1970s1980s---ais-first-winter인공지능의-첫-겨울--backpropagation역전파기법">1970s–1980s - AI’s First Winter(인공지능의 첫 겨울) &amp; Backpropagation(역전파기법)</h4> <p>Discovery: Backpropagation (1986, Rumelhart, Hinton, Williams)</p> <p>Problem: How can multi-layer neural networks be efficiently trained?</p> <p>Solution: Backpropagation introduced a systematic way to compute gradients and update weights in deep networks using the chain rule, which is the cornerstone of deep learning.This allowed to solve non-linear problems.Applications suggested during that period included image recognition and character classification but were limited by computational power and data availability.</p> <p><br/></p> <h4 id="1980s1990s---sequence-processing-and-memory">1980s–1990s - Sequence Processing and Memory</h4> <p>Discovery: Recurrent Neural Networks(RNN) (1986, Rumelhart &amp; McClelland)</p> <p>Problem: How can sequential data be modeled and retain context from prior inputs?</p> <p>Solution: RNNs introduced a feedback loop where outputs from previous steps are fed back as inputs, allowing networks to maintain a “memory” over time.</p> <p>Limitations: RNNs faced vanishing gradient issues, making them ineffective for long sequences -&gt; LSTM was introduced to resolve this issue.</p> <p><br/></p> <h4 id="1997---long-short-term-memorylstm-hochreiter--schmidhuber">1997 - Long Short-Term Memory(LSTM) (Hochreiter &amp; Schmidhuber)</h4> <p>Problem: How can we learn and retain long-term dependencies in sequences</p> <p>Solution: LSTMs introduced gated cells to control the flow of information, solving vanishing gradient problems. Applications include speech recognition and language translation.</p> <p><br/></p> <h4 id="1980s1990s---visual-recognition-and-spatial-data">1980s–1990s - Visual Recognition and Spatial Data</h4> <p>Discovery: Convolutional Neural Networks (CNNs, 1989, LeCun)</p> <p>Problem: How to efficiently process and recognize spatially structured data like images.</p> <p>Solution: CNNs use convolutional layers to detect patterns such as edges and textures by learning spatial hierarchies. Pooling layers reduce dimensionality while preserving critical information.</p> <p>Applications: Handwritten digit recognition (e.g., MNIST dataset) and later extended to more complex tasks like object detection.</p> <p><br/></p> <h4 id="2012---deep-learning-revolution">2012 - Deep Learning Revolution</h4> <p>Discovery: Deep CNNs and AlexNet (2012, Krizhevsky, Sutskever, Hinton)</p> <p>Problem: How to achieve state-of-the-art(SOTA) accuracy in image recognition.</p> <p>Solution: AlexNet leveraged deeper architectures, ReLU activations, and GPUs for training, achieving a breakthrough in the ImageNet competition. (Previous SOTA classification : 74% -&gt; Alexnet <code class="language-plaintext highlighter-rouge">84.69%</code>)</p> <p>Applications: Facial recognition, autonomous vehicles, and medical imaging.</p> <p><br/></p> <h4 id="2014---generative-adversarial-networksgan-goodfellow">2014 - Generative Adversarial Networks(GAN) (Goodfellow)</h4> <p>Problem: How can we generate new output data that resembles an input dataset?</p> <p>Solution: GANs use a generator and discriminator in a competitive framework, enabling applications like image synthesis and style transfer.</p> <p><br/></p> <h4 id="2017---attention-mechanisms-and-transformers-vaswani-et-al">2017 - Attention Mechanisms and Transformers (Vaswani et al.)</h4> <p>Problem: How can we handle long-term dependencies and parallelize(병렬화) sequence processing?</p> <p>Solution: The attention mechanism learns relationships between all inputs simultaneously, eliminating sequential constraints. Transformers like BERT and GPT revolutionized natural language processing (NLP).</p> <p>Applications: Machine translation, summarization, and chatbots.</p> <p><br/></p> <h4 id="2020s---multi-modal-ai-and-real-time-applications">2020s - Multi-Modal AI and Real-Time Applications</h4> <p>Discovery: Multi-Modal Models (e.g., CLIP, DALL-E)</p> <p>Problem: How can we unify processing across different modalities like text, images, and audio?</p> <p>Solution: Pretraining large-scale models that align multiple data types, enabling applications in creative AI and real-time analysis.</p> <p><br/></p> <h4 id="tldr">TL;DR</h4> <ul> <li>Backpropagation solved problem of non-linearity.</li> <li>RNNs/LSTMs enabled handling sequential data.</li> <li>CNNs revolutionized image processing.</li> <li>Transformers led to breakthroughs in NLP and multi-modal AI.</li> </ul>]]></content><author><name></name></author><category term="study"/><category term="ML,"/><category term="DL"/><summary type="html"><![CDATA[Table of Contents 1940s–1950s - Early Foundations 1950s–1960s - Discovery of Neural Networks 1970s–1980s - AI’s First Winter(인공지능의 첫 겨울) \&amp; Backpropagation(역전파기법) 1980s–1990s - Sequence Processing and Memory 1997 - Long Short-Term Memory(LSTM) (Hochreiter \&amp; Schmidhuber) 1980s–1990s - Visual Recognition and Spatial Data 2012 - Deep Learning Revolution 2014 - Generative Adversarial Networks(GAN) (Goodfellow) 2017 - Attention Mechanisms and Transformers (Vaswani et al.) 2020s - Multi-Modal AI and Real-Time Applications TL;DR]]></summary></entry><entry><title type="html">(ENG) Backpropagation</title><link href="https://joohunhyun.github.io/blog/2024/backpropagation/" rel="alternate" type="text/html" title="(ENG) Backpropagation"/><published>2024-12-12T00:00:00+00:00</published><updated>2024-12-12T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/backpropagation</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/backpropagation/"><![CDATA[<p><strong>Table of Contents</strong></p> <ul> <li><a href="#before-delving-in">Before delving in</a> <ul> <li><a href="#fitting-the-curve">Fitting the curve</a></li> <li><a href="#what-is-the-best-curve">What is the “best curve”?</a></li> <li><a href="#minimizing-the-loss-function">Minimizing the loss function</a> <ul> <li><a href="#limitation-of-the-perceptron">Limitation of the Perceptron</a></li> <li><a href="#how-backpropagation-solved-this-issue">How Backpropagation solved this issue?</a></li> </ul> </li> <li><a href="#chain-rule-behind-backpropagation">Chain Rule behind Backpropagation</a> <ul> <li><a href="#composition-of-a-nn">Composition of a NN</a></li> <li><a href="#chain-rule">Chain Rule</a></li> </ul> </li> </ul> </li> <li><a href="#references">References</a></li> </ul> <p><br/></p> <h3 id="before-delving-in">Before delving in</h3> <h4 id="fitting-the-curve">Fitting the curve</h4> <h4 id="what-is-the-best-curve">What is the “best curve”?</h4> <p>Fitting data points across a plane using a curve is the most important question.</p> <p>So what is the “best curve”?</p> <p>Loss function : Measure of total squared distance between the points and the curve</p> <p>🧠 It is referred to as a <strong>function</strong> because it has multiple parameters \(\eta = (k_0 ... k_5)\)</p> <p>The function yields a sigle value, where low value = good fit</p> <h4 id="minimizing-the-loss-function">Minimizing the loss function</h4> <p>How can we find the best configuration of \((k_0 ... k_5)\), or in other words, minimize the loss function?</p> <p>Methods Random pertubation : random changes to parameters</p> <p>How can we make predictions to the value of \(\eta\)$ without performing all calculations via brute-force?</p> <p>Gradient Descent Method</p> <p><a href="path=&quot;assets/img/image.png&quot;">Derivative of a function</a></p> <p>Sometimes the derivative is unknown (not derivable)</p> <h5 id="limitation-of-the-perceptron">Limitation of the Perceptron</h5> <p>a) Linear Separability</p> <p>A single-layer perceptron uses a linear decision boundary to classify data. It only functioned well if the data can be separated by a straight line (or hyperplane in higher dimensions). However, some problems like XOR are not linearly separable.</p> <p>b) Absence of Hidden Layers</p> <p>The perceptron lacks hidden layers. Without them, it cannot model complex relationships between input features.</p> <p>c) Learning is not Incremental</p> <p>Learning is not incremental over time - meaning it has no retention of previous learning.</p> <p>c) Inability to Learn Nonlinear Functions</p> <p>The perceptron updates its weights using a simple rule:</p> \[w_i+1=w_i + \eta(y-\hat{y})x\] <p>This works for linear problems but fails for nonlinear problems, as the perceptron has no mechanism to capture nonlinear patterns.</p> <h5 id="how-backpropagation-solved-this-issue">How Backpropagation solved this issue?</h5> <p>Backpropagation(1986, Hinton) solved these problems by enabling multi-layer networks to learn nonlinear decision boundaries.</p> <p>a) Nonlinear Activation Functions</p> <p>Backpropagation allows the use of nonlinear activation functions (e.g., sigmoid, tanh, ReLU). Nonlinear activations enable the network to combine inputs in complex ways, effectively learning nonlinear decision boundaries.</p> <p>b) Hidden Layers</p> <p>Backpropagation trains networks with multiple layers of neurons (hidden layers). Hidden layers allow the network to create hierarchical representations of data, transforming input features into complex, abstract representations.</p> <p>For example, in the XOR problem:</p> <ol> <li>The first hidden layer transforms the inputs into a new feature space.</li> <li>The second layer uses this new space to create a nonlinear decision boundary.</li> </ol> <p>c) Learning Complex Relationships</p> <p>Backpropagation applies the chain rule to compute gradients layer by layer, allowing the network to adjust weights in all layers based on how they affect the output error. This enables the network to learn mappings for nonlinear functions, solving problems like XOR.</p> <h4 id="chain-rule-behind-backpropagation">Chain Rule behind Backpropagation</h4> <h5 id="composition-of-a-nn">Composition of a NN</h5> <ol> <li>Layers with weights : \(w\) and biases : \(b\)</li> <li>Activation function : \(f\)</li> <li>Ouput function : \(\hat{y}\)</li> <li>Loss function : \(\eta\)</li> </ol> <p>A single layer NN equation, where \(x\) is the input :</p> <ul> <li>The goal is to minimize loss:</li> </ul> \[\hat{y} = f(w \cdot x + b)\] \[\eta=Loss(\hat{y} ,y)\] <h5 id="chain-rule">Chain Rule</h5> <p>The <strong>chain rule</strong>(연쇄법칙)</p> <ol> <li>Given functions \(f\) and \(g\) that are <strong>both differentiable</strong>, and a composite function \(F = f(g(x)) = f \circ g\)</li> <li>Then, \(F'(x) = f'(g(x)) \circ g'(x)\)</li> <li>If we assume \(t=g(x)\)</li> <li>Then, \(\frac{dy}{dx} = \frac{dt}{dx} \cdot \frac{dy}{dt}\)</li> </ol> <h3 id="references">References</h3> <ol> <li><a href="https://www.youtube.com/watch?v=tIeHLnjs5U8">Video Reference</a></li> <li><a href="https://evan-moon.github.io/2018/07/19/deep-learning-backpropagation/">Blog Reference</a></li> </ol>]]></content><author><name></name></author><category term="study"/><category term="backpropagation,"/><category term="DL"/><summary type="html"><![CDATA[backpropagation]]></summary></entry><entry><title type="html">(KOR) 마크다운 문법</title><link href="https://joohunhyun.github.io/blog/2024/markdown-syntax/" rel="alternate" type="text/html" title="(KOR) 마크다운 문법"/><published>2024-12-12T00:00:00+00:00</published><updated>2024-12-12T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/markdown-syntax</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/markdown-syntax/"><![CDATA[<p>‘<a href="https://www.markdownguide.org">공식 문서</a>’</p> <h4 id="문단">문단</h4> <ul> <li>줄바꿈을 두번</li> <li>줄 끝에 역슬래시</li> </ul> <h4 id="목록">목록</h4> <ul> <li>순서가 없는 목록 (bullet points) <ul> <li>(-) 또는 (*) 사용</li> </ul> </li> <li>순서가 있는 목록 <ul> <li>(1.abcd) -&gt; 이런식으로 작성하나, 숫자는 반드시 맞춰서 쓸 필요는 없다.</li> </ul> </li> </ul> <h4 id="글자-모양">글자 모양</h4> <ul> <li>bold : wrap with ** **</li> <li>italicize : wrap with * *</li> </ul> <h4 id="코드블럭">코드블럭</h4> <ul> <li>(```) 사용</li> <li>맥 환경에서는 키보드가 <strong>영어</strong>로 설정되어 있어야 백틱(`)을 사용할 수 있다</li> </ul> <h4 id="블럭">블럭</h4> <ul> <li>(`) 사용</li> <li>노션의 CMD+E 기능과 동일</li> </ul> <h4 id="링크">링크</h4> <p>-<code class="language-plaintext highlighter-rouge">[link_description](url)</code> 형식으로 작성</p> <h4 id="가로줄">가로줄</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>***
OR
- - -
</code></pre></div></div>]]></content><author><name></name></author><category term="study"/><category term="markdown,"/><category term="마크다운,"/><category term="tools"/><summary type="html"><![CDATA[마크다운 문법]]></summary></entry><entry><title type="html">(ENG) Github Commit Message Conventions</title><link href="https://joohunhyun.github.io/blog/2024/github-conventions-copy/" rel="alternate" type="text/html" title="(ENG) Github Commit Message Conventions"/><published>2024-12-11T00:00:00+00:00</published><updated>2024-12-11T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/github-conventions%20copy</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/github-conventions-copy/"><![CDATA[<p>Commit messages should abide to the following convention :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Activity: Commit Message    
</code></pre></div></div> <ul> <li>Activivities <ul> <li><code class="language-plaintext highlighter-rouge">feat</code>: new features</li> <li><code class="language-plaintext highlighter-rouge">fix</code>: fix an error or issue</li> <li><code class="language-plaintext highlighter-rouge">chore</code> : 빌드 수정, 패키지 매니저 설정, 운영 코드 변경이 없는 경우 등</li> <li><code class="language-plaintext highlighter-rouge">mod</code>: modify existing feature</li> <li><code class="language-plaintext highlighter-rouge">rfc</code>: refactor code</li> <li><code class="language-plaintext highlighter-rouge">rmv</code>: remove existing file or directory</li> <li><code class="language-plaintext highlighter-rouge">doc</code>: changes to document or comment</li> </ul> </li> <li>Example <ul> <li><code class="language-plaintext highlighter-rouge">int: initial commit</code></li> <li><code class="language-plaintext highlighter-rouge">add: prettier and eslint</code></li> <li><code class="language-plaintext highlighter-rouge">rfc: refactoring code by prettier</code></li> </ul> </li> </ul>]]></content><author><name></name></author><category term="study"/><category term="tools,"/><category term="github,"/><category term="git"/><summary type="html"><![CDATA[gitub commmit message convetions]]></summary></entry><entry><title type="html">(KOR) 논문 리뷰 방법론</title><link href="https://joohunhyun.github.io/blog/2024/journal-reading/" rel="alternate" type="text/html" title="(KOR) 논문 리뷰 방법론"/><published>2024-12-11T00:00:00+00:00</published><updated>2024-12-11T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/journal-reading</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/journal-reading/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">Lecture notes from Stanford CS230 course</code></p> <p><strong>Table of Contents</strong></p> <ul> <li><a href="#논문을-읽는-단계">논문을 읽는 단계</a></li> <li><a href="#커리어-조언---채용-담당자가-중요시하는-요소">커리어 조언 - 채용 담당자가 중요시하는 요소</a></li> <li><a href="#tldr">TL;DR</a></li> </ul> <hr/> <h4 id="논문을-읽는-단계">논문을 읽는 단계</h4> <ol> <li>정보 수집 <ul> <li>트위터</li> <li>ML 서브레딧  <a href="https://www.reddit.com/r/MachineLearning/">r/MachineLearning</a></li> <li>ML/DL 컨퍼런스 : <a href="https://nips.cc/">NIPS</a>/<a href="https://icml.cc/">ICML</a>/<a href="https://iclr.cc/">ICLR</a></li> </ul> </li> <li>어떻게 읽을 것인가? <ul> <li>많은 양의 논문을 읽어야할 때만 해당됨. 그렇지 않다면 정독하는 것을 추천한다</li> <li>Title/abstract/figures를 읽어본다</li> <li>Intro/conclusion/figures를 읽고, 나머지는 훑어본다 <ul> <li>related work는 과감하게 넘어간다. 대개의 경우 논문의 저자가 지도교수님 등의 논문을 존중하는 의미에서 언급하는 경우가 많다.</li> </ul> </li> <li>수식은 넘어가거나 훑어본다</li> <li>논문을 처음부터 끝까지 읽어본다 (이해가 안되는 부분은 넘어간다)</li> </ul> </li> <li>셀프 인터뷰 <ul> <li>What did the author try to accomplish?</li> <li>What were key elements?</li> <li>What can you use yourself?</li> <li>What other references do you want to follow?</li> </ul> </li> <li>코드 연습 <ul> <li>오픈소스를 다운받아서 실행해본다.</li> <li>밑바닥부터 직접 구현해본다.</li> </ul> </li> </ol> <h4 id="커리어-조언---채용-담당자가-중요시하는-요소">커리어 조언 - 채용 담당자가 중요시하는 요소</h4> <ul> <li>ML 관련 전공지식</li> <li>코딩 능력</li> <li>Meaningful work (의미있는 프로젝트)</li> <li>Open source (github에 코드 게시)</li> <li>인턴쉽</li> </ul> <h4 id="tldr">TL;DR</h4> <p><strong>논문을 읽는 순서</strong></p> <ol> <li>Title/abstract/figures를 읽어본다</li> <li>Intro/conclusion/figures를 읽고, 나머지는 훑어본다</li> <li>수식은 넘어가거나 훑어본다</li> <li>논문을 처음부터 끝까지 읽어본다 (이해가 안되는 부분은 넘어간다)</li> </ol> <p><strong>논문을 읽은 후에 해야할 질문 4가지</strong></p> <ul> <li>What did the author try to accomplish?</li> <li>What were key elements?</li> <li>What can you use yourself?</li> <li>What other references do you want to follow?</li> </ul>]]></content><author><name></name></author><category term="study"/><category term="papers,"/><category term="논문리뷰"/><summary type="html"><![CDATA[논문 리뷰 방법]]></summary></entry></feed>