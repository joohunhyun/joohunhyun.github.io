<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://joohunhyun.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://joohunhyun.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-27T02:51:37+00:00</updated><id>https://joohunhyun.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">(KOR) AI Agents 스터디 자료[SNU CL LAB]</title><link href="https://joohunhyun.github.io/blog/2024/AI-Agents/" rel="alternate" type="text/html" title="(KOR) AI Agents 스터디 자료[SNU CL LAB]"/><published>2024-12-29T00:00:00+00:00</published><updated>2024-12-29T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/AI%20Agents</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/AI-Agents/"><![CDATA[<p><strong>Table of Contents</strong></p> <ul> <li><a href="#0-랩미팅-회의록">0. 랩미팅 회의록</a></li> <li><a href="#1-ai-agents--introduction">1. AI Agents : Introduction</a></li> <li><a href="#2-ai-agents--methodology">2. AI Agents : Methodology</a> <ul> <li><a href="#21-동작-순서">2.1 동작 순서</a></li> <li><a href="#22-동작-원리">2.2 동작 원리</a></li> <li><a href="#23-상호작용">2.3 상호작용</a></li> <li><a href="#24-ai-agent-종류">2.4 AI Agent 종류</a></li> </ul> </li> <li><a href="#3-스터디-자료-정리">3. 스터디 자료 정리</a> <ul> <li><a href="#31-agentic-ai-vs-generative-ai">3.1 Agentic AI vs Generative AI</a></li> <li><a href="#32-agentic-ai-building-autonomous-systems-from-scratch">3.2 Agentic AI: Building Autonomous Systems from Scratch</a></li> <li><a href="#33-the-landscape-of-emerging-ai-agent-architectures-for-reasoning-planning-and-tool-calling-a-survey">3.3 The Landscape of Emerging AI Agent Architectures for Reasoning, Planning, and Tool Calling: A Survey</a> <ul> <li><a href="#singe-mullti-agent-아키텍처-종류">Singe, Mullti agent 아키텍처 종류</a></li> <li><a href="#key-findings">Key Findings</a></li> </ul> </li> <li><a href="#34-ai-agents-vs-agentic-ai--whats-the-difference-and-why-does-it-matter">3.4 AI Agents vs Agentic AI : What’s the Difference and Why Does It Matter?</a></li> <li><a href="#35-the-emergence-of-ai-agent-architecture">3.5 The Emergence of AI Agent Architecture</a></li> <li><a href="#36-best-multi-ai-agent-frameworks">3.6 Best Multi-AI Agent Frameworks</a></li> <li><a href="#38-anatomy-of-agentic-ai">3.8 Anatomy of Agentic AI</a></li> </ul> </li> <li><a href="#4-external-research">4. External Research</a> <ul> <li><a href="#anthropic---buildng-effective-agents-포스트-정리">Anthropic - Buildng Effective Agents 포스트 정리</a></li> <li><a href="#보안-이슈">보안 이슈</a></li> </ul> </li> <li><a href="#5-프레임워크">5. 프레임워크</a> <ul> <li><a href="#crewai---ai-agent-개발용">CrewAI - AI agent 개발용</a></li> </ul> </li> </ul> <hr/> <h3 id="0-랩미팅-회의록">0. 랩미팅 회의록</h3> <ul> <li><strong>AI agent 개발</strong> <ul> <li>DAG LLM → 운용하는 과정에서 단순히 채팅형 웹페이지가 아니라 agent chatbot 아키텍처를 추가할 예정.</li> <li><strong>AI Agent</strong> (발표 등, 누가 할 지 자유롭게 하면 됨) 다음주 화요일/수요일 쯤 줌/슬랙으로 얘기 나누면 됨. <ul> <li>읽고 추가 조사 + 노션 자료/PPT + 발표 (서베이 논문 타고 들어가서, 페이퍼 그래프 사용해서 검색하면 됨) → 공부한 내용 공유</li> </ul> </li> </ul> </li> <li><strong>서비스 아키텍처 구상</strong> (2월 예정) <ul> <li>백엔드와 프론트엔드 작업 방식을 협의 (같이 또는 따로).</li> <li>AI Agent는 학부생의 역량에 맞춰 개발.</li> <li>발제 → 프로덕션에 넣을 수 있는 것 까지. Capstone 느낌.</li> </ul> </li> <li><strong>LG AI</strong> <ul> <li>주로 작업할 일은 없고, 일손이 필요할 때 하는 수작업(도움이 필요하면 요청).</li> <li>데이터 전처리+가공이 힘든데 이거를 해볼 예정.</li> <li>작업만 하면 됨. 언어학적인 것을 평가할 예정.</li> </ul> </li> <li><strong>기타사항</strong> <ul> <li>완전 비대면 근무로, 정해진 기한 내에 주어진 업무 수행.</li> <li>작업 시간은 자유롭게 조정 가능.</li> <li>매주 금요일 오후 2시에 대면 회의 진행.</li> </ul> </li> </ul> <h3 id="1-ai-agents--introduction">1. AI Agents : Introduction</h3> <p>AI agent는 사람의 개입없이 AI가 task 수행을 위한 모든 역할을 수행하는 agent를 의미한다. AI agent는 사용자의 프롬프트 입력 없이, 하위 task를 설계하고, 검토하고, 수행하는 과정(<strong>Self-Prompting</strong>)을 반복하는 특징을 가진다. 변하는 상황에 따라 접근 방식을 스스로 조정하며 목표 달성을 위한 전략을 수립하고 실행한다.</p> <p>AI agent의 요건</p> <ol> <li>작업 실행을 계획하고 사용 가능한 도구를 활용하여 작업을 자율적으로 수행하는 시스템</li> <li>사용자를 대신해 자율적으로 작업을 수행할 수 있는 프로그램</li> <li>인간의 지속적인 입력 필요없이 스스로 생각하고, 결정하고, 행동함</li> </ol> <p>예를 들어, 사용자의 프롬프트가 “<strong>200만원 예산 내로 3박4일 일정으로 일본 여행을 가고 싶어.</strong>“일 경우, AI Agent는:</p> <ul> <li>사용자의 캘린더앱을 확인해 여행 일정 추천</li> <li>skyscanner를 통해 여행 일정에 맞는 항공권 추천</li> <li>숙박 사이트를 통해 예산에 맞는 호텔 검색</li> <li>관광지 웹사이트를 확인해 관광지 운영 시간 등을 확인</li> </ul> <p>기존의 LLM이 성능을 높이기 위해 사용한 기술들:</p> <ol> <li><strong>RAG (Retrieval-Augmented Generation)</strong><br/> RAG는 모델이 자체적으로 답을 생성하는 것뿐만 아니라 외부 지식을 검색하고 이를 답변에 활용할 수 있도록 하는 기술이다. <ul> <li>외부 데이터베이스나 문서에서 관련 정보를 검색(Retrieval)하여 가져온다.</li> <li>검색된 정보를 기반으로 답변을 생성(Generation)한다.<br/> 이를 통해 모델은 훈련 데이터에 포함되지 않은 정보나 최신 정보를 활용할 수 있어 보다 정확하고 유용한 답변을 제공할 수 있다.</li> </ul> </li> <li><strong>Chain of Thought (CoT)</strong><br/> Chain of Thought은 복잡한 문제를 단계별로 해결하는 방법론이다. <ul> <li>모델이 한 번에 최종 답을 출력하는 대신, 중간 과정을 명시적으로 표현하며 사고의 흐름을 보여준다.</li> <li>예를 들어, 수학 문제를 풀 때 계산 과정을 순차적으로 나열하는 방식이다.<br/> 이는 모델이 복잡한 문제를 더 정확하게 해결할 수 있도록 돕는다.</li> </ul> </li> <li><strong>Few-shot Prompting</strong><br/> Few-shot Prompting은 모델에 몇 가지 예제를 제공하여 작업의 맥락을 이해시키는 기법이다. <ul> <li>예제를 입력 프롬프트에 포함시켜 모델이 특정 작업이나 문제 유형을 학습하지 않아도 수행할 수 있도록 돕는다.</li> <li>이를 통해 모델이 훈련되지 않은 작업에 대해서도 높은 정확도로 수행할 수 있다.</li> </ul> </li> <li><strong>Vector Search</strong><br/> 벡터 검색은 데이터나 문장을 임베딩 벡터로 변환한 후, 유사성을 기반으로 검색하는 기술이다. <ul> <li>모델이 문맥적으로 가장 관련성 높은 정보를 빠르게 찾을 수 있도록 한다.</li> <li>특히, 대규모 데이터베이스에서 적합한 데이터를 검색하는 데 유용하다.<br/> 이는 질문-응답 시스템이나 추천 시스템에서 자주 사용된다.</li> </ul> </li> <li><strong>Memory</strong><br/> 메모리 기술은 모델이 이전 대화나 맥락을 기억하도록 만들어, 연속적인 대화를 가능하게 하는 방법이다. <ul> <li>사용자와의 대화 기록이나 모델이 이전에 생성한 내용을 저장하고 참조한다.</li> <li>이를 통해 더 자연스럽고 일관성 있는 대화를 유지할 수 있다.<br/> 예를 들어, 사용자가 이전에 언급한 내용을 기반으로 추가 정보를 제공하거나 질문에 답변할 수 있다.</li> </ul> </li> </ol> <p><br/></p> <h3 id="2-ai-agents--methodology">2. AI Agents : Methodology</h3> <h4 id="21-동작-순서">2.1 동작 순서</h4> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/16-480.webp 480w,/assets/img/16-800.webp 800w,/assets/img/16-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/16.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ol> <li>environment를 파악하고</li> <li>수집한 정보를 활용하여</li> <li>목표 달성을 위한 계획을 세우고</li> <li>이를 실행함</li> </ol> <h4 id="22-동작-원리">2.2 동작 원리</h4> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/17-480.webp 480w,/assets/img/17-800.webp 800w,/assets/img/17-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/17.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ol> <li>observations를 통해 environment를 파악하고</li> <li>past experiences, abilities, goals/preferencees/prior knowledge를 바탕으로 actions 수행</li> <li>1,2 번 (반복)</li> </ol> <p>용어 정리</p> <ul> <li>environment : agent가 작동하는 영역/도메인 (여행 계획 수립 agent예시의 경우, 사용자의 캘린더, 위치정보, 언어설정, 등)</li> <li>abilities/prior knowledge : 모델이 데이터를 통해 이미 학습한 지식</li> <li>goals/preferences : 사용자의 요청의 목적, 수행할 task들을 agent가 스스로 판단</li> <li>observations : 주어진 환경에 대해 수집한 정보</li> <li>past experiences : Agent가 가진 과거의 경험</li> </ul> <h4 id="23-상호작용">2.3 상호작용</h4> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/18-480.webp 480w,/assets/img/18-800.webp 800w,/assets/img/18-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/18.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="24-ai-agent-종류">2.4 AI Agent 종류</h4> <p>단순 반응형 에이전트 (Reactive Agent)</p> <ul> <li><strong>특징</strong>: 과거의 데이터를 저장하지 않고, 현재 환경에서 관찰한 정보를 바탕으로 즉각적인 반응을 보이는 에이전트</li> <li><strong>예시</strong>: <ul> <li>자동문 시스템: 센서를 통해 사람의 존재를 인식하고 문을 여는 역할 수행</li> <li>온도 조절기: 현재 온도를 기준으로 난방 또는 냉방을 수행</li> </ul> </li> </ul> <p>상태 기반 에이전트 (Model-Based Agent)</p> <ul> <li><strong>특징</strong>: 현재 상태와 과거 상태를 내부적으로 저장하여 의사결정을 수행하며, 환경에 대한 모델을 사용하여 복잡한 작업을 처리할 수 있음</li> <li><strong>예시</strong>: <ul> <li>네비게이션 시스템: 목적지와 현재 위치를 바탕으로 최적의 경로를 계산</li> </ul> </li> </ul> <p>목표 지향형 에이전트 (Goal-Based Agent)</p> <ul> <li><strong>특징</strong>: 목표 중심으로 작동하며, 현재 상태와 목표 상태의 차이를 줄이기 위한 계획을 수립함</li> <li><strong>예시</strong>: <ul> <li>로봇 청소기: 방의 청소가 필요한 위치를 탐지하고 효율적으로 움직임</li> <li>물류 로봇: 특정 지점에 물건을 운반하는 작업을 수행</li> </ul> </li> </ul> <p>유틸리티 기반 에이전트 (Utility-Based Agent)</p> <ul> <li><strong>특징</strong>: 목표 달성뿐만 아니라 목표 달성의 “질”을 고려하여 유틸리티 함수(만족도, 이익 등)를 기반으로 최적의 선택을 수행함</li> <li><strong>예시</strong>: <ul> <li>자율주행 차량: 안전, 시간, 연료 효율성을 동시에 고려하여 경로 선택</li> <li>추천 시스템: 사용자 선호도에 따라 최적의 옵션을 추천</li> </ul> </li> </ul> <p>학습 에이전트 (Learning Agent)</p> <ul> <li><strong>특징</strong>: 경험을 통해 학습하고 시간이 지남에 따라 성능을 점진적으로 개선하며, 학습 요소, 성능 요소, 비평 요소, 문제 생성기를 포함한 구성 요소로 작동</li> <li><strong>예시</strong>: <ul> <li>AlphaGo: 체스 또는 바둑과 같은 게임을 스스로 학습하고 개선</li> <li>챗봇: 사용자와의 대화 기록을 기반으로 점진적으로 대화 능력 향상</li> </ul> </li> </ul> <p>다중 에이전트 시스템 (Multi-Agent System)</p> <ul> <li><strong>특징</strong>: 여러 에이전트가 협력하거나 경쟁하며 목표를 달성하는 시스템으로, 각 에이전트는 독립적으로 작동하며 상호작용을 통해 복잡한 문제를 해결함</li> <li><strong>예시</strong>: <ul> <li>스마트 그리드: 전력 분배를 최적화하는 시스템</li> <li>온라인 게임 AI: 다수의 캐릭터 간 협력 및 경쟁 (예: Pacman)</li> </ul> </li> </ul> <p>하이브리드 에이전트 (Hybrid Agent)</p> <ul> <li><strong>특징</strong>: 위에서 언급된 여러 종류의 에이전트를 조합하여 설계된 시스템으로, 복잡한 문제 해결을 위해 다양한 접근 방식을 사용함</li> <li><strong>예시</strong>: <ul> <li>자율주행 차량: 감지(단순 반응형)와 경로 계획(목표 지향형)을 동시에 수행</li> <li>인공지능 비서(Siri, Alexa): 학습 및 목표 지향형 기능을 결합</li> </ul> </li> </ul> <p><br/></p> <h3 id="3-스터디-자료-정리">3. 스터디 자료 정리</h3> <h4 id="31-agentic-ai-vs-generative-ai">3.1 Agentic AI vs Generative AI</h4> <p>TL;DR : <strong>Agentic Workflow</strong>는 Zero-shot보다 훨씬 더 높은 정확도를 보인다.</p> <ul> <li><strong>LLMs</strong>: 입력된 패턴에 반응하며 작동하는 시스템</li> <li><strong>Agentic AI</strong>: 자율성, 목표 지향적 행동, 학습 및 환경 인식을 통해 지속적인 문제 해결 능력이 필요한 문제도 해결 가능</li> <li><strong>Agentic AI의 특징</strong> <ul> <li>autonomy</li> <li>goal directed behavior</li> <li>learning from actions and experiences</li> <li>Environmental Perception : AI must understand its environment</li> </ul> </li> </ul> <p>Andrew Ng은 코딩 작업에 있어서 Agentic Workflow의 우수성을 입증하기 위해 케이스 스터디를 진행한 바 있다.<strong>HumanEval coding benchmark</strong>를 벤치마크로 사용해 다음과 같은 실험을 진행했다.</p> <ul> <li><strong>Zero-shot prompting</strong>: 추가 가이던스(prompting) 없이 문제를 해결하도록 요청하는 방법 <ul> <li>GPT-3.5: 48% 정확도</li> <li>GPT-4: 67% 정확도</li> </ul> </li> <li><strong>Agentic Workflow</strong>: 작업을 이해, 코딩, 테스트 및 디버깅 등의 단계로 나누어 AI가 반복적으로 개선하도록 설계 <ul> <li>GPT-3.5가 GPT-4보다 우수한 성과를 보임</li> </ul> </li> </ul> <h4 id="32-agentic-ai-building-autonomous-systems-from-scratch">3.2 Agentic AI: Building Autonomous Systems from Scratch</h4> <p><strong>MAS 예시 소스코드</strong>: <a href="https://github.com/zaai-ai/lab">GitHub 코드</a></p> <p>Agentic AI의 필수 구성 요소 (클래스 2개를 작성해야 함)</p> <ol> <li><strong>Agent</strong> <ul> <li><strong>LLM</strong>: GPT-4 등</li> <li><strong>Role</strong>: 정보 처리, 데이터베이스 조회, 상호작용 조정</li> <li><strong>Backstory</strong>: 현재 환경에 대한 사전 지식</li> <li><strong>Goal</strong>: 에이전트의 목표</li> </ul> </li> <li><strong>Task</strong> <ul> <li><strong>Description</strong>: 수행할 작업과 목표 설명</li> <li><strong>Output</strong>: 출력 형식 정의 (예: 텍스트, JSON, HTML)</li> </ul> </li> </ol> <h4 id="33-the-landscape-of-emerging-ai-agent-architectures-for-reasoning-planning-and-tool-calling-a-survey">3.3 The Landscape of Emerging AI Agent Architectures for Reasoning, Planning, and Tool Calling: A Survey</h4> <p>현재 복잡한 작업을 해결하는 데 단일 에이전트 시스템이 더 적합한지 다중 에이전트 시스템이 더 적합한지에 대한 논의가 진행 중이다.</p> <ul> <li>Reasoning</li> <li>Planning <ul> <li>task decomposition, multi-plan selection, external module-aided planning, reflection and refinement and memory-augmented planning</li> <li>Plan Like a Graph (PLaG) is an approach that represents plans as directed graphs, with multiple steps being executed in parallel</li> </ul> </li> <li>Effective Tool Calling <ul> <li>Tools enable the agent to interact with external data sources, send or retrieve information from existing APIs</li> <li>Multi-agent patterns can address the issues of parallel tasks and robustness since individual agents can work on individual subproblems</li> </ul> </li> </ul> <p>한글 번역</p> <p>Agent를 잘 개발하기 위해서는 다음이 필요하다.</p> <ul> <li><strong>추론(Reasoning)</strong></li> <li><strong>계획(Planning)</strong> <ul> <li>작업 분해(Task Decomposition), 다중 계획 선택(Multi-Plan Selection), 외부 모듈을 활용한 계획(External Module-Aided Planning), 반성 및 정제(Reflection and Refinement), 기억 증강 계획(Memory-Augmented Planning)</li> <li><strong>Plan Like a Graph, PLaG</strong>: 이 접근 방식은 계획을 방향 그래프(directed graph)로 표현하며, 여러 단계를 병렬로 실행하는 방식</li> </ul> </li> <li><strong>도구 호출(Effective Tool Calling)</strong> <ul> <li>도구는 에이전트가 외부 데이터 소스와 상호작용하거나 기존 API를 통해 정보를 송수신하는 데 도움을 준다.</li> <li>다중 에이전트 패턴은 개별 에이전트가 각각의 하위 문제를 처리할 수 있어 병렬 작업 및 안정성 문제를 해결할 수 있습니다.</li> </ul> </li> </ul> <h5 id="singe-mullti-agent-아키텍처-종류">Singe, Mullti agent 아키텍처 종류</h5> <p><strong>Single-Agent 아키텍처 종류</strong></p> <ul> <li>ReAct (Reason + Act) <ul> <li>The agent first writes a thought about the given task. It then performs an action based on that thought, and the output is observed. This cycle can repeat until the task is complete</li> <li>When evaluated on the HotpotQA dataset, the ReAct method only hallucinated 6% of the time, compared to 14% using the chain of thought (CoT) method</li> <li>the model can repetitively generate the same thoughts and actions and fail to create new thoughts to provoke finishing the task and exiting the ReAct loop.</li> <li>Incorporating human feedback during the execution of the task would likely increase its effectiveness and applicability in real-world scenarios</li> </ul> </li> <li>RAISE <ul> <li>RAISE is built upon the ReAct method, with the addition of a memory mechanism that mirrors human short-term and long-term memory. It does this by using a scratchpad for short-term storage and a dataset of similar previous examples for long-term storage.</li> <li>Improves the agent’s ability to retain context in longer conversations</li> <li>Issues: First, RAISE struggles to understand complex logic, limiting its usefulness in many scenarios. Additionally, RAISE agents often hallucinated with respect to their roles or knowledge</li> </ul> </li> <li>Reflexion <ul> <li>Reflexion is a single-agent pattern that uses self-reflection through linguistic feedback. By utilizing metrics such as success state, current trajectory, and persistent memory, this method uses an LLM evaluator to provide</li> <li>specific and relevant feedback to the agent. This results in an improved success rate as well as reduced hallucination compared to Chain-of-Thought and ReAct.</li> <li>Reflexion is susceptible to “non-optimal local minima solutions”. It also uses a sliding window for long-term memory, rather than a database. This means that the volume of long-term memory is limited by the token limit of the language model.</li> </ul> </li> <li>AutoGPT + P <ul> <li>AutoGPT + P (Planning) is a method that addresses reasoning limitations for agents that command robots in natural language [1]. AutoGPT+P combines object detection and Object Affordance Mapping (OAM) with a planning system driven by a LLM. This allows the agent to explore the environment for missing objects, propose alternatives, or ask the user for assistance with reaching its goal.</li> </ul> </li> <li>LATS <ul> <li>Language Agent Tree Search (LATS) is a single-agent method that synergizes planning, acting, and reasoning by using trees. This technique, inspired by Monte Carlo Tree Search, represents a state as a node and taking an action as traversing between nodes. It uses LM-based heuristics to search for possible options, then selects an action using a state evaluator.</li> <li>often uses more computational resources and takes more time to complete than other single-agent methods</li> </ul> </li> </ul> <p>한글 번역</p> <p>ReAct (Reason + Act)</p> <ul> <li>에이전트는 주어진 작업에 대해 먼저 생각을 작성하고, 그 생각에 기반한 행동을 수행한 후 결과를 관찰합니다. 이 사이클은 작업이 완료될 때까지 반복될 수 있습니다.</li> <li>HotpotQA 데이터셋에서 평가한 결과, ReAct 방법은 체인 오브 쿼트(CoT) 방법에 비해 6%만 허위 생성(hallucination)을 했고, CoT 방법은 14%의 허위 생성이 있었습니다.</li> <li>모델은 반복적으로 같은 생각과 행동을 생성하며, 새로운 생각을 만들어 작업을 완료하거나 ReAct 루프를 종료하지 못할 수 있습니다.</li> <li>작업 실행 중 인간 피드백을 통합하면 실제 상황에서 효과성과 적용 가능성이 증가할 수 있습니다.</li> </ul> <p>RAISE</p> <ul> <li>RAISE는 ReAct 방법을 기반으로 하며, 인간의 단기 및 장기 기억을 반영하는 기억 메커니즘을 추가한 방법입니다. 이는 단기 저장을 위한 스크래치패드와 유사한 이전 예제들로 구성된 장기 저장 데이터를 사용합니다.</li> <li>에이전트의 긴 대화에서 맥락을 유지하는 능력을 향상시킵니다.</li> <li>문제점: RAISE는 복잡한 논리를 이해하는 데 어려움을 겪어 많은 시나리오에서 유용성이 제한됩니다. 또한, RAISE 에이전트는 종종 자신의 역할이나 지식에 대해 허위 정보를 생성하는 경향이 있습니다.</li> </ul> <p>Reflexion</p> <ul> <li>Reflexion은 언어적 피드백을 통해 자기 반성을 사용하는 단일 에이전트 패턴입니다. 성공 상태, 현재 진행 경로, 지속적인 기억과 같은 메트릭스를 활용하여, LLM 평가기를 사용해 에이전트에게 구체적이고 관련성 있는 피드백을 제공합니다.</li> <li>이 방법은 Chain-of-Thought와 ReAct에 비해 성공률이 향상되고 허위 생성이 감소합니다.</li> <li>Reflexion은 “비최적의 지역 최솟값 솔루션”에 취약할 수 있습니다. 또한, 장기 기억을 위한 데이터베이스 대신 슬라이딩 윈도우를 사용하므로 언어 모델의 토큰 제한에 의해 장기 기억 용량이 제한됩니다.</li> </ul> <p>AutoGPT + P</p> <ul> <li>AutoGPT + P(Planning)은 자연어로 로봇을 제어하는 에이전트의 추론 한계를 해결하는 방법입니다. AutoGPT+P는 객체 탐지 및 객체 용도 매핑(Object Affordance Mapping, OAM)을 LLM 기반의 계획 시스템과 결합하여, 에이전트가 환경을 탐색해 누락된 객체를 찾아 대안을 제시하거나 목표 달성에 도움을 주기 위해 사용자에게 요청할 수 있도록 합니다.</li> </ul> <p>LATS</p> <ul> <li>Language Agent Tree Search (LATS)는 계획, 행동, 추론을 트리를 사용하여 시너지 효과를 내는 단일 에이전트 방법입니다. 이 기법은 몬테카를로 트리 탐색(Monte Carlo Tree Search)에 영감을 받아 상태를 노드로, 행동을 노드 간 이동으로 나타냅니다. LM 기반의 휴리스틱을 사용하여 가능한 옵션을 검색하고, 상태 평가기를 사용해 행동을 선택합니다.</li> <li>다른 단일 에이전트 방법에 비해 자원을 더 많이 사용하고 time complexity가 더 길다.</li> </ul> <p><strong>Multi-Agent 아키텍처 종류</strong></p> <p>Embodied LLM Agents</p> <ul> <li>This architecture contains a vertical component through the leader agent, as well as a horizontal component from the ability for agents to converse with other agents besides the leader</li> <li>Agent teams with an organized leader complete their tasks nearly 10% faster than teams without a leader.</li> <li>Agents spent most of their time giving orders to one another (~50% of communication), splitting their remaining time between sharing information, or requesting guidance</li> </ul> <p>DyLAN</p> <ul> <li>Dynamic LLM-Agent Network (DyLAN) framework creates a dynamic agent structure that focuses on complex tasks like reasoning and code generation</li> </ul> <p>AgentVerse</p> <ul> <li>AgentVerse contains four primary stages for task execution: recruitment, collaborative decision making, independent action execution, and evaluation. This can be repeated until the overall goal is achieved.</li> <li>The researchers found that horizontal teams are generally best suited for collaborative tasks like consulting, while vertical teams are better suited for tasks that require clearer isolation of responsibilities for tool calling</li> </ul> <p>MetaGPT</p> <ul> <li>Many multi-agent architectures allow agents to converse with one another while collaborating on a common problem</li> <li>MetaGPT addresses the issue of unproductive chatter amongst agents by requiring agents to generate structured outputs like documents and diagrams instead of sharing unstructured chat messages</li> </ul> <p>한글 번역</p> <p>Embodied LLM Agents</p> <ul> <li>이 아키텍처는 리더 에이전트를 통한 수직적인 요소와, 에이전트들이 리더 외에도 다른 에이전트들과 대화할 수 있는 수평적인 요소를 결합합니다.</li> <li>조직된 리더를 가진 에이전트 팀은 리더가 없는 팀보다 작업을 약 10% 더 빠르게 완료합니다.</li> <li>에이전트들은 대부분의 시간을 서로에게 명령을 내리는 데 사용하며(~50%의 커뮤니케이션), 나머지 시간은 정보를 공유하거나 지침을 요청하는 데 씁니다.</li> </ul> <p>DyLAN</p> <ul> <li><strong>Dynamic LLM-Agent Network (DyLAN)</strong> 프레임워크는 추론이나 코드 생성과 같은 복잡한 작업에 집중하는 동적 에이전트 구조를 생성합니다.</li> </ul> <p>AgentVerse</p> <ul> <li><strong>AgentVerse</strong>는 작업 실행을 위한 네 가지 주요 단계로 구성됩니다: 모집, 협력적 의사결정, 독립적 행동 실행, 그리고 평가. 이 과정은 전체 목표가 달성될 때까지 반복될 수 있습니다.</li> <li>연구자들은 horizontal한 팀이 상담과 같은 협력적인 작업에 적합하고, vertical한 팀은 도구 호출을 위한 책임 분리가 더 명확한 작업에 적합하다고 발견했습니다.</li> </ul> <p>MetaGPT</p> <ul> <li>많은 <strong>multi-agent</strong> 아키텍처는 에이전트들이 공통의 문제를 해결하며 서로 대화할 수 있게 합니다.</li> <li>그러나, 서로 메세지를 주고 받을 수 있는 아키텍처를 만들면 비생산적인 대화가 오갈 수 있다 -&gt; 효율성 저하</li> <li><strong>MetaGPT</strong>는 에이전트들 간의 비생산적인 대화를 해결하기 위해, 에이전트들이 구조화된 출력물(예: 문서, 다이어그램)을 생성하도록 요구하며, 비구조적(이건 좀 아니지 않냐? 식의)인 메시지를 공유하지 않도록 한다.</li> </ul> <h5 id="key-findings">Key Findings</h5> <p>단일 에이전트 vs 다중 에이전트 아키텍처</p> <ul> <li><strong>Single-agent</strong>는 도구가 명확히 정의되고 프로세스가 잘 정립된 작업에 적합합니다. 또한 구현이 더 간단하고, 다른 에이전트의 피드백이나 불필요한 대화가 없다는 장점이 있습니다. 하지만, 추론과 정제 능력이 부족하다면 실행 루프에 갇혀 목표를 달성하지 못할 수 있습니다.</li> <li><strong>Multi-agent</strong>는 여러 인물의 피드백이 중요한 작업에 적합합니다. 예를 들어, 문서 생성 시 한 에이전트가 다른 에이전트에게 피드백을 제공하는 방식입니다. 또한 다중 에이전트 시스템은 작업이나 워크플로우의 병렬 처리가 필요한 경우 유용합니다. 예시가 제공되지 않은 경우, 다중 에이전트가 단일 에이전트보다 더 잘 수행된다고 합니다.</li> </ul> <p>에이전트들의 Asynchronous Task Execution</p> <ul> <li><strong>Single-agent</strong>는 여러 비동기 호출을 동시에 시작할 수 있지만, 각 작업을 순차적으로 계획하고 실행해야 하므로 진정한 병렬적인 처리가 어렵습니다.</li> <li><strong>Multi-agent</strong>는 각 에이전트가 독립적으로 작업을 수행할 수 있어 더 유연하고 동적인 작업 분배가 가능하며, 개별 에이전트가 다른 에이전트의 작업 상태에 방해받지 않고 진행할 수 있습니다.</li> </ul> <p>피드백과 인간 감독(human oversight)의 영향</p> <ul> <li>에이전트가 복잡한 문제를 해결할 때, 첫 시도에서 완벽한 해결책을 제공하기는 어려우며, 반복적인 피드백과 정제가 필수적입니다. 피드백을 통해 에이전트는 더 나은 방향으로 수정할 가능성이 높아집니다.</li> <li><strong>Human oversight</strong>는 에이전트의 반응을 인간의 기대에 맞게 조정하여 비효율적이거나 잘못된 접근을 방지합니다. 인간의 검증과 피드백이 포함된 에이전트 아키텍처는 더 신뢰할 수 있고 안정적인 결과를 제공합니다.</li> </ul> <p>Challenges with Group Conversations and Information Sharing</p> <ul> <li><strong>Multi-agent</strong> 아키텍처는 에이전트 간 메시지를 공유하는 과정에서 문제가 발생할 수 있습니다. 불필요한 대화가 에이전트의 추론 능력과 작업 실행을 방해할 수 있으며, 이는 팀 효율성을 낮춥니다.</li> <li><strong>Vertical architecture</strong>에서는 역할 분담이 명확하여 방해 요소를 줄일 수 있지만, 중요한 정보가 제대로 전파되지 않으면 혼란이나 허위 생성이 발생할 수 있습니다.</li> </ul> <p>Impact of Role Definition and Dynamic Teams</p> <ul> <li><strong>Role definition</strong>은 단일 및 다중 에이전트 아키텍처에서 중요한 요소입니다. 역할 정의는 에이전트가 주어진 작업에 집중하고, 불필요한 역할을 피하게 하며, 과도한 허위 생성도 방지합니다.</li> <li><strong>Dynamic teams</strong>는 작업의 필요에 따라 에이전트를 적절히 투입하고 제거하는 방식으로 효과적인 팀 작업을 지원합니다.</li> </ul> <h4 id="34-ai-agents-vs-agentic-ai--whats-the-difference-and-why-does-it-matter">3.4 AI Agents vs Agentic AI : What’s the Difference and Why Does It Matter?</h4> <p>TL;DR : <strong>Agentic AI와 AI Agents의 차이점</strong>에 대한 글</p> <p>AI Agents vs Agenic AI</p> <ul> <li><strong>자율성</strong>: Agentic AI는 독립적이고 지속적인 의사결정 가능</li> <li><strong>상호작용</strong>: AI Agents는 주로 사용자의 명령에 따라 작동</li> </ul> <p>예시</p> <ul> <li><strong>Agentic AI</strong>: 자율주행 자동차 (테슬라 FSD), 아마존 창고 로봇</li> <li><strong>AI Agents</strong>: 고객 서비스 챗봇, GitHub Copilot</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/19-480.webp 480w,/assets/img/19-800.webp 800w,/assets/img/19-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/19.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="35-the-emergence-of-ai-agent-architecture">3.5 The Emergence of AI Agent Architecture</h4> <p>TL;DR : LAM, Model Orchestration, Vision-지원 언어 모델, function calling을 사용하면, 에이전트는 문제 해결, 디지털 환경 (digital landscape) 탐색, 및 자율적인 학습 능력을 가질 수 있게 된다.</p> <p>주요 개념</p> <ul> <li><strong>Retrieval-Augmented Generation (RAG)</strong>: 작은 언어 모델(SLM)을 보완하여 큰 언어 모델과 유사한 성능 제공</li> <li><strong>Model Orchestration</strong>: SLM을 결합하여 특정 작업을 지원함</li> <li><strong>Function calling</strong> : 대형 언어 모델(LLM)의 기능을 텍스트 생성 기증을 넘어 확장성을 제공함</li> <li><strong>LAM(대형 행동 모델)</strong> : 단순한 언어 생성을 넘어 실제 있을 법한 시나리오에서 의미 있는 행동을 수행할 수 있도록 설계되었다. 이를 통해 AI는 데이터베이스 쿼리나 API 호출과 같은 외부 프로세스를 실행할 수 있다.</li> </ul> <h4 id="36-best-multi-ai-agent-frameworks">3.6 Best Multi-AI Agent Frameworks</h4> <p>TL;DR : 멀티 AI 에이전트를 개발할 시 사용할 프레임워크를 추천하는 글</p> <p><strong>추천 프레임워크</strong></p> <ul> <li><strong>소프트웨어 개발</strong>: AutoGen (Microsoft) <ul> <li>코드 생성 및 복잡한 다중 에이전트 코딩 워크플로우에 가장 적합합니다.</li> </ul> </li> <li><strong>초보자에게 추천</strong>: OpenAI Swarm, CrewAI <ul> <li>사용자 친화적</li> <li>복잡한 설정 요구 없이 다중 에이전트 AI에 적합함</li> </ul> </li> <li><strong>복잡한 작업에 최적화</strong>: LangGraph <ul> <li>높은 flexibility 제공하며, 고급 사용자를 위해 설계되어 에이전트의 커스텀 로직과 orchestration을 허용</li> </ul> </li> <li><strong>오픈소스 LLM</strong>: LangGraph <ul> <li>다양한 API를 지원</li> </ul> </li> <li><strong>저비용 개발용</strong>: Magentic-One <ul> <li>사전 패키지 설정과 generalist approach를 제공하여 초기 비용을 절감할 수 있다. Swarm과 CrewAI라는 옵션도 있음.</li> </ul> </li> <li><strong>즉시 적용 가능한 프레임워크</strong>: CrewAI <ul> <li>환경설정이 빠르고</li> <li>사용이 직관적이며</li> <li>신속한 에이전트 생성이 필요할 경우 적합함</li> <li>Swarm과 Magentic-One도 좋으나 커뮤니티 형성이 덜 되어있음</li> </ul> </li> </ul> <h4 id="38-anatomy-of-agentic-ai">3.8 Anatomy of Agentic AI</h4> <p>TL;DR <strong>Agentic AI 아키텍처</strong>와 이를 구현할 때 고려해야 할 점을 다룬다.</p> <p>아키텍처 예시 :</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/20-480.webp 480w,/assets/img/20-800.webp 800w,/assets/img/20-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/20.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>개발 시 고려할 점 :</p> <ul> <li><strong>모듈화와 확장성</strong>: 복잡한 작업을 처리할 수 있도록 설계해야 함</li> <li><strong>적응성</strong>: 환경에 따라 학습 및 행동을 개선할 수 있어야 함</li> <li><strong>멀티모달 상호작용</strong>: 디지털 및 물리적 환경과 상호작용이 되도록 개발해야 함</li> <li><strong>협력</strong>: 공유 메모리를 활용한 에이전트 간 협력</li> </ul> <h3 id="4-external-research">4. External Research</h3> <h4 id="anthropic---buildng-effective-agents-포스트-정리">Anthropic - Buildng Effective Agents 포스트 정리</h4> <p>클라우드에서는 workflow와 agent를 구분한다. <strong>Workflow</strong>란 LLM과 tools가 사전 정의된 code path를 통해 orchestrate 되는 것을 의미하는 반면, <strong>Agents</strong>는 LLM이 동적으로 자신들의 프로세스와 tool 사용을 정의하고, task 수행을 자율적으로 컨트롤하는 시스템을 의미한다. Agent는 flexibility나 모델-주도-의사결정 과정이 필요한 경우에 사용하고, workflow는 반복적이거나 잘 정의된(well-defined) task를 수행할 때 용의한 시스템이다. 에이전트를 개발할 때 있어서, LangGraph, Rivet, Vellum 등의 프레임워크가 있으나, 이런 프레임워크는 복잡한 layer들을 추가하여 디버깅을 까다롭게 한다. 그럼으로, 클라우드는 LLM API를 직접 사용하여 agentic system을 개발하는 것을 권장한다. 코드 examples는 여기서 확인해볼 수 있다 -&gt; <a href="https://github.com/anthropics/anthropic-cookbook/tree/main/patterns/agents">클라우드의 cookbook</a>.</p> <p><strong>Prompt Chaining</strong></p> <p>Prompt Chaining 방식은 task가 여러 subtask로 깔끔하게 떨어지는 경우에 사용하는 것을 권장한다. 이 방식의 경우 Tradeoff가 발생하게 되는데, latency&lt;-&gt;accuracy의 tradeoff 관계가 형성된다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/22-480.webp 480w,/assets/img/22-800.webp 800w,/assets/img/22-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/22.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Routing</strong></p> <p>Routing 방식은 input을 분류하여 다음 작업으로 전달해주는 과정을 의미한다. CS센터 챗봇 개발에 용의한 아키텍처이다. Input(고객 문의) -&gt; 일반 문의/제품 문의/환불 요청 3중 1택 -&gt; Output(챗봇 전달 내용)</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/23-480.webp 480w,/assets/img/23-800.webp 800w,/assets/img/23-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/23.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Orchestrator-Workers</strong></p> <p>Orchestrator-Workers 방식에서는 Central LLM이 task를 동적으로 세분화하여 worker LLM에 이를 넘겨주고 그 결과를 종합한다. 해당 방식은 최종 goal의 하위 task들을 예측할 수 없는 복잡한 작업들에 적합하다. 하위 작업은 미리 정의되지 않고, 특정 입력에 따라 orchestrator가 이를 결정한다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/24-480.webp 480w,/assets/img/24-800.webp 800w,/assets/img/24-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/24.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Evaluator-optimizer</strong></p> <p>Evaluator-optimizer 방식에서는 LLM call Generator가 응답을 생성하고 이를 LLM Call Evaluator가 받아 Accept하거나, Reject를 할 경우, 평가와 피드백을 제공한다. 반복적으로 수행하는 작업을 한다. LLM Call Evaluator가 응답을 Accept할 떄까지 Loop이 생성된다(exit condition). 해당 방식은 명확한 평가 기준이 있고 반복적인 개선 작업을 통해 측정 가능한 가치가 있을 경우 효과적이다. 예를 들어 웹 서핑을 통해 정보를 수집하기 위해 여러 차례의 검색과 분석이 필요한 복잡한 검색 작업의 경우, Evaluator가 추가 검색이 필요한지 여부를 결정해 검색 정확도를 높힐 수 있다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/25-480.webp 480w,/assets/img/25-800.webp 800w,/assets/img/25-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/25.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Agents</strong></p> <p>Agent 방식은 요즘 각광받고 있는 워크플로우이다. Agent의 워크플로우를 요약하자면 다음과 같다. Tools 설계 시 고려할 점 : 에이전트는 tools와 feedback loop에 의존하므로, tools와 관련된 코드를 명확하고 신중하게 설계하는 것이 중요합니다. 또한, Agent의 자율적인 특성은 높은 토큰 비용과 오류의 가능성이 높아짐을 의미한다. 적절한 exit condition를 <strong>무조건</strong> 구현하고, 샌드박스 환경에서 광범위한 테스트를 사전에 수행할 것을 권장함.</p> <ol> <li>Input: 에이전트가 사용자의 명령, 혹은 사용자와의 대화(Q&amp;A)를 통해 작업을 시작하고, 작업을 명확히 정의함.</li> <li>계획 수립 단계: 하위 작업들이 명확히 정의되면, 에이전트들이 계획을 세우고 자율적으로 작업을 진행합니다.</li> <li>실행 단계: 에이전트는 각 단계에서 환경으로부터 “정확한 정보(ground truth)”를 도출해 진행 상황을 평가합니다.</li> <li>사용자와의 상호작용(Optional): 에이전트는 중간 체크포인트나 장애물에 직면했을 때 작동을 멈추고, 사용자로부터 추가 피드백이나 판단을 요청합니다.</li> <li>Completion 단계: 작업이 성공적으로 완료되거나, 사전에 정의된 exit condition이 충족되면 작동울 멈춘다.</li> </ol> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/26-480.webp 480w,/assets/img/26-800.webp 800w,/assets/img/26-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/26.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>다음 자료는 coding Agent의 high-level 워크플로우입니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/27-480.webp 480w,/assets/img/27-800.webp 800w,/assets/img/27-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/27.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>최종 설계</strong></p> <p>위에 설명한 워크플로우들을 목적에 맞게 결합할 수 있다. 모든 LLM 기능 개발과 마찬가지로, 성공의 비결은:</p> <ol> <li>구현</li> <li>성능 측정</li> </ol> <p>1번과 2번을 반복하는 것이다. 한 가지를 더 강조하자면, 성능이 확실히 개선되는 경우에만 기능을 추가하는 것을 권장한다.</p> <p><a href="https://www.anthropic.com/research/building-effective-agents">출처</a></p> <h4 id="보안-이슈">보안 이슈</h4> <p>AI가 컴퓨터 화면을 읽게 하여 컴퓨터를 조작하는 자율성 높은 Agentic AI 개발 시 보안 문제가 야기된다. prompt injection는 특정 웝사이트에 어떤 prompt(listener 등)를 끼워넣는 행위를 의미하는데, agentic AI가 이를 실행해버리는 경우도 있다.</p> <h3 id="5-프레임워크">5. 프레임워크</h3> <h4 id="crewai---ai-agent-개발용">CrewAI - AI agent 개발용</h4> <p><a href="https://docs.crewai.com/concepts/flows">official docs</a></p> <p><strong>작동방식</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/21-480.webp 480w,/assets/img/21-800.webp 800w,/assets/img/21-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/21.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>구성 요소</strong></p> <table> <thead> <tr> <th>구성 요소</th> <th>설명</th> <th>주요 특징</th> </tr> </thead> <tbody> <tr> <td><strong>Crew</strong></td> <td>최상위 조직</td> <td>• AI 에이전트 팀 관리<br/>• 워크플로우 감독<br/>• 협업 보장<br/>• 결과 제공</td> </tr> <tr> <td><strong>AI Agents</strong></td> <td>특화된 팀원</td> <td>• 특정 역할 수행 (연구자, 작가 등)<br/>• 지정된 도구 사용<br/>• 작업 위임 가능<br/>• 자율적 의사결정</td> </tr> <tr> <td><strong>Process</strong></td> <td>워크플로우 관리 시스템</td> <td>• 협업 패턴 정의<br/>• 작업 할당 관리<br/>• 상호작용 관리<br/>• 효율적 실행 보장</td> </tr> <tr> <td><strong>Tasks</strong></td> <td>개별 작업</td> <td>• 명확한 목표 설정<br/>• 특정 도구 사용<br/>• 전체 프로세스에 기여<br/>• 실행 가능한 결과 생산</td> </tr> </tbody> </table> <p><br/></p> <p><strong>연동 방식</strong></p> <ol> <li><strong>Crew</strong>가 전체 운영을 조직화합니다.</li> <li><strong>AI Agents</strong>는 자신들이 특화된 작업을 수행합니다.</li> <li><strong>Process</strong>는 원활한 협업을 보장합니다.</li> <li>최종 목표 달성을 위해 <strong>Tasks</strong>를 수행합니다.</li> </ol>]]></content><author><name></name></author><category term="study"/><category term="NLP"/><summary type="html"><![CDATA[Table of Contents 0. 랩미팅 회의록 1. AI Agents : Introduction 2. AI Agents : Methodology 2.1 동작 순서 2.2 동작 원리 2.3 상호작용 2.4 AI Agent 종류 3. 스터디 자료 정리 3.1 Agentic AI vs Generative AI 3.2 Agentic AI: Building Autonomous Systems from Scratch 3.3 The Landscape of Emerging AI Agent Architectures for Reasoning, Planning, and Tool Calling: A Survey Singe, Mullti agent 아키텍처 종류 Key Findings 3.4 AI Agents vs Agentic AI : What’s the Difference and Why Does It Matter? 3.5 The Emergence of AI Agent Architecture 3.6 Best Multi-AI Agent Frameworks 3.8 Anatomy of Agentic AI 4. External Research Anthropic - Buildng Effective Agents 포스트 정리 보안 이슈 5. 프레임워크 CrewAI - AI agent 개발용]]></summary></entry><entry><title type="html">(ENG) Breakdown of AutoGPT’s Archtecture</title><link href="https://joohunhyun.github.io/blog/2024/AutoGPT/" rel="alternate" type="text/html" title="(ENG) Breakdown of AutoGPT’s Archtecture"/><published>2024-12-29T00:00:00+00:00</published><updated>2024-12-29T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/AutoGPT</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/AutoGPT/"><![CDATA[<h3 id="1-installation">1. Installation</h3> <p>This tutorial assumes you have Docker, VSCode, git and npm installed.</p> <p><strong>Installation</strong></p> <ol> <li>Clone the repository</li> <li>Setup dependencies by running <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ./run
</code></pre></div> </div> </li> </ol> <p><strong>Creating your own agent</strong></p> <ol> <li> <p>Create agents by running :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./run agent create YOUR_AGENT_NAME
</code></pre></div> </div> </li> <li>Run agents with : <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./run agent start YOUR_AGENT_NAME`
</code></pre></div> </div> </li> <li>Frontend for the agents can be accessed from <a href="http://localhost:8000/">localhost:8000</a> upon logging in</li> <li>Running the following code will initiate <code class="language-plaintext highlighter-rouge">kill -9 PID</code> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./run agent stop
</code></pre></div> </div> </li> <li>To benchmark agents :</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # see the benchmarks available
  ./run benchmark categories list
  ./run benchmark tests list

  # run the benchmark tests for your agent
  ./run benchmark start YOUR_AGENT_NAME
</code></pre></div></div>]]></content><author><name></name></author><category term="study"/><category term="NLP"/><summary type="html"><![CDATA[1. Installation]]></summary></entry><entry><title type="html">(KOR) KR-BERT:A Small-Scale Korean-Specific Language Model</title><link href="https://joohunhyun.github.io/blog/2024/KR-BERT/" rel="alternate" type="text/html" title="(KOR) KR-BERT:A Small-Scale Korean-Specific Language Model"/><published>2024-12-26T00:00:00+00:00</published><updated>2024-12-26T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/KR-BERT</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/KR-BERT/"><![CDATA[<ul> <li><a href="#1-논문-요약">1. 논문 요약</a> <ul> <li><a href="#11-rationale">1.1 Rationale</a></li> <li><a href="#12-methodology-요약">1.2 Methodology 요약</a></li> <li><a href="#13-conclusion">1.3 Conclusion</a></li> </ul> </li> <li><a href="#2-mbert의-한계">2. mBERT의 한계</a> <ul> <li><a href="#21-corpus말뭉치-domain의-한계">2.1 Corpus(말뭉치) Domain의 한계</a></li> <li><a href="#22-한국어의-언어적-특성을-충분히-고려하지-않은-점">2.2 한국어의 언어적 특성을 충분히 고려하지 않은 점</a></li> <li><a href="#23-모델의-크기">2.3 모델의 크기</a></li> </ul> </li> <li><a href="#3-methodology">3. Methodology</a> <ul> <li><a href="#31-subcharacter-text-representation">3.1 Subcharacter Text Representation</a></li> <li><a href="#32-subword-vocabulary">3.2 Subword Vocabulary</a></li> </ul> </li> <li><a href="#4-results">4. Results</a> <ul> <li><a href="#masked-lm-accuracy">Masked LM Accuracy</a></li> </ul> </li> <li><a href="#5-related-work--benchmarks">5. Related Work / Benchmarks</a></li> </ul> <hr/> <p><br/></p> <h3 id="1-논문-요약">1. 논문 요약</h3> <p><br/></p> <h4 id="11-rationale">1.1 Rationale</h4> <p>Multilingual-BERT(이하 mBERT)는 위키백과의 104개 언어로 된 문서들을 기반으로 학습된 모델이다. 그러나, 모든 언어의 언어적 특성을 학습시킬 수는 없기 때문에 비영어 다운스트림 작업(non-English downstream tasks)에는 정확도가 다소 떨어진 모습을 보인다. <strong>Downstream tasks</strong>란 자연어 처리(NLP)에서 사전 학습된 언어 모델을 활용하여 수행하는 특정 응용 작업 (예: 감정 분석, 개체명 인식, 문장 분류 등)을 의미한다.</p> <p>한국어는 만개 이상의 문자(character)를 사용하고, 독어나 불어와 같은 굴절어보다 형태적으로 복잡하다. mBERT에서는 이 가운데 오직 1,187개의 문자만이 포함되었다. 또한, mBERT 모델은 104개의 언어 데이터를 포함하기에 크기가 과도하게 크다는 단점이 존재한다. 그래서, ALBERT나 DistilBERT처럼 모델을 축소하면서도 성능을 유지하는 방법이 필요하다.</p> <p>요약하자면:</p> <ol> <li>mBERT는 모델 크기가 과도하게 크다.</li> <li>mBERT는 non-English downstream tasks에서 성능이 다소 떨어진다.</li> <li>모델을 축소하면서 성능을 유지하는 한국어 언어모델이 필요하다.</li> </ol> <p>KR-BERT는 이런 점들을 해결하기 위해 고안된 새로운 한국어 언어모델이다.</p> <p><br/></p> <h4 id="12-methodology-요약">1.2 Methodology 요약</h4> <p><br/></p> <h4 id="13-conclusion">1.3 Conclusion</h4> <ul> <li>KR-BERT는 다음의 downstream tasks들에서 mBERT의 성능을 능가했다. <ul> <li>senti- ment analysis</li> <li>Question-Answering</li> <li>Named Entity Recognition(NER)</li> <li>Paraphrase Detection</li> </ul> </li> <li>KR-BERT는 다른 한국어 모델들에 비해 다운스트림 작업에서 더 좋은 성능을 보이거나 비슷한 성과를 보였다.</li> <li>형태소가 많은 한국어에 맞게 서브-캐릭터 기반 모델과 Bidirectional-WordPiece 토크나이저를 사용하여 적은 자원으로도 효과적인 성능을 달성했다.</li> </ul> <p><br/> <br/></p> <h3 id="2-mbert의-한계">2. mBERT의 한계</h3> <p><br/></p> <h5 id="21-corpus말뭉치-domain의-한계">2.1 Corpus(말뭉치) Domain의 한계</h5> <p>GCamemBERT와 같은 언어별 특화된(Language Specific) BERT 모델들은 법률 데이터, 뉴스 기사 등, 다양한 데이터 소스를 사용하여 학습된 반면, mBERT는 유저들이 직접 작성한 데이터 소스(블로그 글, 댓글, 등)를 사용하지 않고, 위키백과 포스트들의 언어적 특성을 기반으로만 학습되어 언어 사용(limited in its domain with respect to language usage - 직역하면 언어 사용이지만 어휘력일 것이라고 생각됨) 측면에서 한계가 존재한다.</p> <p><br/></p> <h5 id="22-한국어의-언어적-특성을-충분히-고려하지-않은-점">2.2 한국어의 언어적 특성을 충분히 고려하지 않은 점</h5> <p>2.2.1 Rare Character Problem</p> <p>라틴 문자 기반 언어는 단어를 문자 단위로 분리하여 처리할 수 있는 반면, 한국어의 언어적 특성상 음절 단위로 처리되어 Out-of-Vocabulary(OoV)가 라틴 문자 기반 언어보다 많을수밖에 없다. 그럼으로, 이런 한국어의 특성을 고려한 새로운 BERT Vocabulary가 필요하다.</p> <p>2.2.2 교착언어에 적합하지 않은 모델</p> <p>교착어(agglutinative language)란 문법적 의미를 전달하기 위해 주로 접사를 단단히 결합하는 언어를 의미한다. 교착어는 형태론적인 복잡성(morphological complexity) 때문에 vocabulary를 표현하기 어렵다. 한국어 역시 교착언어에 해당하며, mBERT는 이 문제를 제대로 처리하지 않은 것으로 보인다.</p> <p>2.2.3 Lack of Meaningful Tokens</p> <p>독일어의 경우, mBERT 모델의 어휘에 명확한 semantic meaning이 없는 subword unit이 포함되어 있었다. 한국어에서도 이와 유사한 문제가 존재했는데, 대부분의 단어가 형태소와 같은 단위가 아닌 단일 문자로 tokenized 되었기 떄문이다. 이 문제를 해결하기 위해, 한국어 텍스트와 한국어의 언어적 특성을 고려한 vocabulary 및 tokenizer를 구현했다.</p> <p><br/></p> <h5 id="23-모델의-크기">2.3 모델의 크기</h5> <p>대형 모델들은 많은 양의 dataset, parameter, voabulary를 필요로 한다. mBERT는 167M, RoBERTa는 355M 파라미터를 사용해 자원의 제약을 받기 마련인데, KR-BERT는 적은 parameter와 훈련 데이터를 사용하면서 mBERT와 비슷한 성능을 유지할 수 있었다.</p> <p><br/> <br/></p> <h3 id="3-methodology">3. Methodology</h3> <p>KR-BERT를 Multilingual BERT, Kor- BERT, 그리고 KoBERT와 비교했다.</p> <p><br/></p> <h4 id="31-subcharacter-text-representation">3.1 Subcharacter Text Representation</h4> <p>한국어 텍스트는 Text-&gt; 한글 -&gt; graphemes의 형태로 분해 가능하다. 이런 특성을 반영하기 위해, KR-BERT는 syllable character와 sub-character 두 가지 말뭉치 표현 방식을 사용하여 new vocabulary와 BERT model을 학습시켰다. BPE 알고리즘을 적용하면, 다음과 같은 tokenization이 가능해진다.</p> <p><code class="language-plaintext highlighter-rouge">Example : 뜀(ttwim, "jumping")은 ㄸㅟ(ttwi, "jump")와 ᄆ(m, "-ing")으로 분해될 수 있다</code></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/15-480.webp 480w,/assets/img/15-800.webp 800w,/assets/img/15-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/15.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>KR-BERT 모델은 나머지 벤치마크 모델들과 달리, 음절 문자 이외에도 하위 문자 표현을 사용해 다양한 한국어 동사/형용사의 공통된 특성을 학습할 수 있었다.</p> <p><br/></p> <h4 id="32-subword-vocabulary">3.2 Subword Vocabulary</h4> <h3 id="4-results">4. Results</h3> <h4 id="masked-lm-accuracy">Masked LM Accuracy</h4> <h3 id="5-related-work--benchmarks">5. Related Work / Benchmarks</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/13-480.webp 480w,/assets/img/13-800.webp 800w,/assets/img/13-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/13.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/14-480.webp 480w,/assets/img/14-800.webp 800w,/assets/img/14-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/14.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><category term="study"/><category term="papers"/><category term="NLP"/><summary type="html"><![CDATA[1. 논문 요약 1.1 Rationale 1.2 Methodology 요약 1.3 Conclusion 2. mBERT의 한계 2.1 Corpus(말뭉치) Domain의 한계 2.2 한국어의 언어적 특성을 충분히 고려하지 않은 점 2.3 모델의 크기 3. Methodology 3.1 Subcharacter Text Representation 3.2 Subword Vocabulary 4. Results Masked LM Accuracy 5. Related Work / Benchmarks]]></summary></entry><entry><title type="html">(ENG) MLP and DNN</title><link href="https://joohunhyun.github.io/blog/2024/MLP-DNN/" rel="alternate" type="text/html" title="(ENG) MLP and DNN"/><published>2024-12-17T00:00:00+00:00</published><updated>2024-12-17T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/MLP-DNN</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/MLP-DNN/"><![CDATA[<ul> <li>Perceptron -&gt; delta rule</li> <li>MLP (2~3 layers) -&gt; backpropagation</li> <li>DNN (~10 layers) -&gt; using ReLU instead of sigmoid</li> </ul> <h4 id="mlps-problem">MLP’s problem</h4> <ul> <li>Major issue of designing MLP is how many hidden units are optimal? <ul> <li>너무 만으면 : overfit</li> <li>너무 적으면 : underfit</li> </ul> </li> <li>As the number of hidden layers increase, the sigmoid function’s relatively small gradient repeatedly gets multiplied. -&gt; this makes the gradient close to 0, and the weights are not updated (<strong>vanishing gradient problem</strong>)</li> </ul> <p><strong>Solution to this problem</strong></p> <ol> <li>Using a ReLU Function</li> </ol> <p>The Rectified Linear Unit (ReLU) function is defined as:</p> \[f(x)=max(0,x)\] <p>ReLU has a gradient of 1 1 for positive inputs, which prevents the gradient from shrinking excessively as it is propagated through the network.</p> <p>Advantages of ReLU:</p> <ul> <li>Avoids vanishing gradients: The gradient remains constant for positive inputs, ensuring that weights continue to be updated.</li> <li>Computational efficiency: ReLU is simpler to compute than sigmoid or tanh.</li> <li>Sparsity: It introduces sparsity in activations (many outputs are zero), which can improve generalization.</li> </ul> <p>However, ReLU can suffer from the dying ReLU problem, where neurons become inactive (outputting zero) due to large negative gradients. Variants like Leaky ReLU and Parametric ReLU address this issue.</p> <ol> <li>Xavier Initialization</li> </ol> <p>Proper weight initialization is crucial for mitigating vanishing or exploding gradients. The Xavier initialization (or Glorot initialization) ensures that the variance of activations and gradients is maintained across layers.</p> <p>Benefits:</p> <ul> <li>Prevents vanishing/exploding gradients by keeping the variance of inputs and outputs consistent across layers.</li> <li>Helps the network converge faster.</li> </ul> <ol> <li>Batch Normalization</li> </ol> <p>Batch Normalization (BatchNorm) normalizes the inputs to each layer by adjusting the mean and variance of the activations during training.</p> <p>Benefits</p> <ul> <li>Improves gradient flow: Normalization reduces internal covariate shift, allowing deeper networks to train effectively.</li> <li>Stabilizes learning: It reduces sensitivity to initialization and learning rate.</li> <li>Acts as regularization: BatchNorm has a slight regularization effect, reducing the need for dropout in some cases.</li> </ul> <ol> <li>Early stopping</li> </ol> <p>Terminating training once a performance plateau has been reached.</p> <p>Example performance plateus</p> <ul> <li>Error is small enough</li> <li>Number of epochs</li> <li>Pruning the network</li> <li>Training with noisy samples</li> </ul>]]></content><author><name></name></author><category term="study"/><category term="ML"/><summary type="html"><![CDATA[Perceptron -&gt; delta rule MLP (2~3 layers) -&gt; backpropagation DNN (~10 layers) -&gt; using ReLU instead of sigmoid]]></summary></entry><entry><title type="html">(ENG) RNN and LSTM</title><link href="https://joohunhyun.github.io/blog/2024/RNN/" rel="alternate" type="text/html" title="(ENG) RNN and LSTM"/><published>2024-12-17T00:00:00+00:00</published><updated>2024-12-17T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/RNN</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/RNN/"><![CDATA[<p><strong>Table of Contents</strong></p> <ul> <li><a href="#recurrent-neural-networks">Recurrent Neural Networks</a></li> <li><a href="#exploding-and-vanishing-gradient-problem">Exploding and Vanishing Gradient Problem</a></li> <li><a href="#long-short-term-memory-lstm">Long Short-Term Memory (LSTM)</a> <ul> <li><a href="#lstm-cell-structure">LSTM Cell Structure</a></li> <li><a href="#differences-between-rnn-and-lstm">Differences Between RNN and LSTM</a></li> </ul> </li> <li><a href="#tldr">TL;DR</a></li> </ul> <hr/> <h4 id="recurrent-neural-networks">Recurrent Neural Networks</h4> <p>Recurrent Neural Networks (RNNs) are designed to handle sequential data by maintaining an internal state that captures information about previous time steps. This makes them ideal for tasks like speech recognition, machine translation, and time series analysis.</p> <ul> <li><strong>Structure</strong>: In an RNN, each hidden unit has connections to itself and to other hidden units, allowing information to flow across time steps.</li> <li><strong>Mathematics</strong>: At each time step \(t\), the hidden state \(h_t\) is updated using the input \(x_t\) and the previous hidden state \(h_{t-1}\): \(h_t = \tanh(W_{xh}x_t + W_{hh}h_{t-1} + b_h)\) Where: <ul> <li>\(W_{xh}\): Weight matrix for the input.</li> <li>\(W_{hh}\): Weight matrix for the hidden state.</li> <li>\(b_h\): Bias term.</li> </ul> </li> </ul> <h4 id="exploding-and-vanishing-gradient-problem">Exploding and Vanishing Gradient Problem</h4> <p>RNNs use the same weight matrices \(W_{hh}\) and \(W_{xh}\) at every time step. During backpropagation through time (BPTT), gradients are repeatedly multiplied by these matrices, which can cause:</p> <ul> <li><strong>Vanishing gradients</strong>: Gradients shrink exponentially, making it difficult to update weights and learn long-term dependencies.</li> <li><strong>Exploding gradients</strong>: Gradients grow exponentially, leading to instability.</li> </ul> <h4 id="long-short-term-memory-lstm">Long Short-Term Memory (LSTM)</h4> <p><strong>Long Short-Term Memory (LSTM)</strong> networks are a type of RNN specifically designed to handle the vanishing gradient problem. They achieve this by introducing a more complex structure within each unit that allows information to be selectively remembered or forgotten over long time steps.</p> <h5 id="lstm-cell-structure">LSTM Cell Structure</h5> <p>An LSTM unit consists of four interacting layers that control the flow of information:</p> <ol> <li> <p><strong>Forget Gate</strong>: Determines which parts of the previous cell state \(C_{t-1}\) should be forgotten: \(f_t = \sigma(W_f \cdot [h_{t-1}, x_t] + b_f)\) Where \(\sigma\) is the sigmoid activation function.</p> </li> <li> <p><strong>Input Gate</strong>: Decides what new information to store in the cell state: \(i_t = \sigma(W_i \cdot [h_{t-1}, x_t] + b_i)\) A candidate cell state \(\tilde{C}_t\) is created: \(\tilde{C}_t = \tanh(W_C \cdot [h_{t-1}, x_t] + b_C)\)</p> </li> <li> <p><strong>Cell State Update</strong>: Combines the forget gate and the input gate to update the cell state: \(C_t = f_t \odot C_{t-1} + i_t \odot \tilde{C}_t\) Where \(\odot\) denotes element-wise multiplication.</p> </li> <li> <p><strong>Output Gate</strong>: Determines the next hidden state \(h_t\): \(o_t = \sigma(W_o \cdot [h_{t-1}, x_t] + b_o)\) The hidden state is calculated as: \(h_t = o_t \odot \tanh(C_t)\)</p> </li> </ol> <hr/> <h5 id="differences-between-rnn-and-lstm">Differences Between RNN and LSTM</h5> <table> <thead> <tr> <th>Feature</th> <th>RNN</th> <th>LSTM</th> </tr> </thead> <tbody> <tr> <td><strong>Architecture</strong></td> <td>Simple structure with one update equation.</td> <td>Complex structure with gates for controlling memory.</td> </tr> <tr> <td><strong>Gradient Issues</strong></td> <td>Suffers from vanishing/exploding gradients.</td> <td>Designed to avoid vanishing gradients.</td> </tr> <tr> <td><strong>Long-Term Dependencies</strong></td> <td>Struggles to learn long-term patterns.</td> <td>Efficiently captures long-term dependencies.</td> </tr> <tr> <td><strong>Use Cases</strong></td> <td>Short-term dependencies.</td> <td>Long-term dependencies (e.g., speech, text).</td> </tr> </tbody> </table> <hr/> <h4 id="tldr">TL;DR</h4> <p>While RNNs are effective for sequence modeling, their training can be hindered by the vanishing gradient problem, especially for long-term dependencies. LSTMs address this limitation by introducing gating mechanisms that allow the model to selectively retain and forget information, making them a powerful tool for tasks involving sequential data.</p>]]></content><author><name></name></author><category term="study"/><category term="DL"/><summary type="html"><![CDATA[Table of Contents]]></summary></entry><entry><title type="html">(ENG) Training and Evaluating Deep Networks</title><link href="https://joohunhyun.github.io/blog/2024/deep-learning/" rel="alternate" type="text/html" title="(ENG) Training and Evaluating Deep Networks"/><published>2024-12-17T00:00:00+00:00</published><updated>2024-12-17T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/deep-learning</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/deep-learning/"><![CDATA[<h4 id="training-and-evaluating-deep-networks">Training and Evaluating Deep Networks</h4> <p>When dealing with DL, the following components are vital</p> <ol> <li>training set</li> <li>test set</li> <li>validation set : used to tune a model’s hyperparameters for model selection. Also, it prevents overfitting by early stopping</li> </ol> <h5 id="hyperparameter-tuning">Hyperparameter Tuning</h5> <p>Hyperparameters in DL are usually tuned heuristically by hand or using grid search.</p> <h5 id="dropout">Dropout</h5> <p>Dropout is a form of regualization that randomly deletes units and their connections during training.</p> <p>Pros</p> <ul> <li>과적합 방지, 뉴런간의 의존성을 줄여 학습된 모델의 일반화 성능 향상</li> <li>간단한 구현</li> </ul> <p>Cons</p> <ul> <li>Additional overhead : 훈련 중에 매번 mask를 생성하고 적용</li> <li>학습 속도 감소</li> </ul> <h5 id="unsupervised-pretraining">Unsupervised Pretraining</h5> <p>This method can be useful when the volume of labeled data is small relative to the model’s capacity.</p> <ul> <li>딥러닝 초기의 학습 안정화와 데이터 부족 문제를 해결하기 위해고안된 기법</li> </ul>]]></content><author><name></name></author><category term="study"/><category term="DL"/><summary type="html"><![CDATA[Training and Evaluating Deep Networks]]></summary></entry><entry><title type="html">(ENG) Feature Selection, Extraction, and Ensamble Methods</title><link href="https://joohunhyun.github.io/blog/2024/feature/" rel="alternate" type="text/html" title="(ENG) Feature Selection, Extraction, and Ensamble Methods"/><published>2024-12-17T00:00:00+00:00</published><updated>2024-12-17T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/feature</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/feature/"><![CDATA[<p><strong>Table of Contents</strong></p> <hr/> <h4 id="feature-subset-selection">Feature Subset Selection</h4> <p>Definition : Feature subset selection finds a subset of original features without new features</p> <h5 id="1-filter-method">1. Filter Method</h5> <ul> <li>Evaluates features with performance measures based on information gain or distance between each attribute in the class</li> <li>장점 : computationally siple and fast</li> <li>단점 : slow searching</li> <li>해결책 : use a single-attribute evaluator with ranking</li> </ul> <h5 id="2-wrapper-method">2. Wrapper Method</h5> <ul> <li>Searches for best combination of features among <strong>all</strong> posttible combination</li> <li>장점 : generally better performance, simple and direct</li> <li>단점 : \(O(n^2)\) time complexity - slow</li> <li>해결책 <ul> <li>eliminate irrelevant features</li> <li>eliminate redundant attributes</li> </ul> </li> </ul> <h5 id="3-embedded-method">3. Embedded method</h5> <ul> <li>Uses ML models for classification and then an obtimal subset of features/ranking of feature is built by the classifier algorithm</li> </ul> <h5 id="search-methods">Search Methods</h5> <ul> <li>Weka 예제에서는 classfier(wrapper, etc)와 search method 둘 다 정의해야한다.</li> </ul> <h5 id="different-search-methods">Different Search Methods</h5> <ol> <li>Exhaustive : \(2^n\) subsets</li> <li>Backwards</li> <li>Forwards</li> <li>Bidirectional</li> </ol> <h2><br/></h2> <h4 id="feature-extraction-aka-reducing-dimentionality">Feature Extraction (AKA: Reducing Dimentionality)</h4> <p>Definition : extracts new set of features from the original features</p> <h5 id="pca">PCA</h5> <ul> <li>Definition : unsupervised approach to examine relations among a set of variables</li> <li>When to use this? <ul> <li>PCA is useful in reducing the dimentionality of 3-D, 4-D scatterplots (왜 사용하냐 : visually difficult to interpret data points in high-dimensional space)</li> </ul> </li> <li>Ex : Compressing MNIST- dataset using PCA (to reduce dimension)</li> </ul> <h2 id="-1"><br/></h2> <h4 id="ensamble-method">Ensamble Method</h4> <ul> <li>Definition : 여러개의 모델들을 조합해서 더욱 정확한 결정을 내리는 방법 (위원회 운영과 비슷)</li> </ul> <p>Types of Ensamble Methods:</p> <ol> <li>Boosting</li> <li>Bagging</li> <li>Stacking</li> </ol> <h4 id="1-boosting-adaboost"><strong>1. Boosting: AdaBoost</strong></h4> <p>Boosting is an ensemble learning technique that combines the predictions of several weak learners (simple models, such as decision trees) to create a strong learner. <strong>AdaBoost (Adaptive Boosting)</strong> is one of the most popular boosting algorithms.</p> <h5 id="how-adaboost-works"><strong>How AdaBoost Works</strong></h5> <p>AdaBoost works iteratively, focusing on the data points that are harder to classify by assigning them higher weights in subsequent iterations.</p> <ol> <li><strong>Initialize Weights</strong>: <ul> <li>Assign equal weights to all training samples: \(w_i = \frac{1}{N}, \, \forall i \in \{1, 2, \dots, N\}\) Where \(N\) is the total number of training samples.</li> </ul> </li> <li><strong>Train Weak Learner</strong>: <ul> <li>Train a weak learner (e.g., a shallow decision tree) using the weighted training dataset.</li> </ul> </li> <li><strong>Calculate Weighted Error</strong>: <ul> <li>Compute the error \(e_t\) of the weak learner: \(e_t = \frac{\sum_{i=1}^N w_i \cdot I(y_i \neq \hat{y}_i)}{\sum_{i=1}^N w_i}\) Where: <ul> <li>\(y_i\): True label of sample \(i\).</li> <li>\(\hat{y}_i\): Predicted label by the weak learner.</li> <li>\(I(y_i \neq \hat{y}_i)\): Indicator function that equals 1 if the prediction is incorrect.</li> </ul> </li> </ul> </li> <li><strong>Compute Alpha (Model Weight)</strong>: <ul> <li>Calculate the weight of the weak learner: \(\alpha_t = \frac{1}{2} \ln\left(\frac{1 - e_t}{e_t}\right)\) The higher the accuracy of the weak learner, the larger its contribution to the final model.</li> </ul> </li> <li><strong>Update Sample Weights</strong>: <ul> <li>Increase the weights of misclassified samples to emphasize them in the next iteration: \(w_i \leftarrow w_i \cdot \exp(\alpha_t \cdot I(y_i \neq \hat{y}_i))\)</li> <li>Normalize the weights so they sum to 1: \(w_i \leftarrow \frac{w_i}{\sum_{j=1}^N w_j}\)</li> </ul> </li> <li><strong>Repeat</strong>: <ul> <li>Train the next weak learner using the updated weights, and repeat for \(T\) iterations.</li> </ul> </li> <li><strong>Final Prediction</strong>: <ul> <li>Combine the predictions of all weak learners using their weights \(\alpha_t\): \(H(x) = \text{sign} \left( \sum_{t=1}^T \alpha_t \cdot h_t(x) \right)\) Where: <ul> <li>\(h_t(x)\): Prediction from the \(t\)-th weak learner.</li> </ul> </li> </ul> </li> </ol> <hr/> <h5 id="advantages-of-adaboost"><strong>Advantages of AdaBoost</strong></h5> <ul> <li>Improves accuracy by focusing on difficult samples.</li> <li>Works well with simple weak learners.</li> <li>Robust to overfitting in many cases.</li> </ul> <h5 id="disadvantages-of-adaboost"><strong>Disadvantages of AdaBoost</strong></h5> <ul> <li>Sensitive to noisy data and outliers, as they receive higher weights.</li> <li>Can be computationally expensive for large datasets.</li> </ul> <h5 id="2-baggingstands-for-boostrap-aggrevating">2. Bagging(stands for: Boostrap Aggrevating)</h5> <p>Bagging은 앙상블 기법들 가운데 가장 간단한 방법이다(taking a vote, or weighted vote). Decision Tree의 경우, training set에 따라서 그 구조가 매우 민감하게 바뀐다. 이런 경우에는 1) training set을 여러 개 만들고 2) 각각 모델을 만들어서 3) voting을 한다. In numerical prediction, taking the average of all predictions.</p> <p>Breiman(1996) noticed that an ensamble of trees improved when the trees differed significantly from each other, today called <strong>Random Forest</strong>. Bagging was able to create a diverse ensamble of classifiers by introducing randomness into the learning alg’s input, which resulted in <strong>better results</strong>. In a DT, picking the best option can be randomized by picking one of the N best options at random instead of a signle winner (ex: top 3 options, top 5 options)</p> <p><strong>Methods of picking different “winners” in bagging</strong></p> <ol> <li>elite : picking the best one</li> <li>randomization : picking 1 randomly from top 5 candidates</li> <li>stochastic : top5 중에서 룰렛으로 고르는 방법 (weighted)</li> </ol> <h5 id="3-stacking">3. Stacking</h5> <p>Stacking is used on models built by different learning algorithsm. For example, stacking can be used when you want to form a classifier for a given dataset with A) deicision tree inducer B) naive bayes learnner and C) instance based learning scheme.</p> <p>Stacking involves a <strong>metalearner</strong> that replaces the voting procedure of boosing and bagging. Metalearner is used to discover how to best combine the output of the base learners to determine which classifiers are the reliable ones.</p> <ul> <li>base learners : level-0 models</li> <li>meta learner : level-1 model</li> <li>predictions from base models are inputs to the meta learner. (funnel처럼 위에서 아래로 내려온다)</li> </ul> <p>TL;DR : Stacking combines predictions of base learners using metalearner(NOT voting)</p>]]></content><author><name></name></author><category term="study"/><category term="ML"/><summary type="html"><![CDATA[Table of Contents]]></summary></entry><entry><title type="html">(KOR) 연구실 안전교육 배속하는 방법</title><link href="https://joohunhyun.github.io/blog/2024/skip-safety-skip-copy/" rel="alternate" type="text/html" title="(KOR) 연구실 안전교육 배속하는 방법"/><published>2024-12-16T00:00:00+00:00</published><updated>2024-12-16T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/skip-safety-skip%20copy</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/skip-safety-skip-copy/"><![CDATA[<p>24’12월 기준, 이 방법이 제일 편한 듯. 다른 방법들은 다 막힌 듯 하다.</p> <p>참고 :</p> <ul> <li>중간중간에 퀴즈도 있으니 유의해야한다.</li> <li>배속은 16배까지만 가능하다.</li> </ul> <p><strong>크롬</strong> 환경에서 연구실 안전교육 동영상 재생 후 개발자모드 콘솔 <code class="language-plaintext highlighter-rouge">F12</code>에 해당 코드 붙여넣기:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>document.querySelector('video').playbackRate = 16;
</code></pre></div></div>]]></content><author><name></name></author><category term="study"/><category term="tools"/><summary type="html"><![CDATA[24’12월 기준, 이 방법이 제일 편한 듯. 다른 방법들은 다 막힌 듯 하다.]]></summary></entry><entry><title type="html">(ENG) SVM, SVC</title><link href="https://joohunhyun.github.io/blog/2024/SVM-SVC/" rel="alternate" type="text/html" title="(ENG) SVM, SVC"/><published>2024-12-16T00:00:00+00:00</published><updated>2024-12-16T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/SVM-SVC</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/SVM-SVC/"><![CDATA[<p><strong>Table of Contents</strong></p> <hr/> <h4 id="classification-models">Classification Models</h4> <p>Definition : 두개의 class A and B를 feature space에서 분리하는 모델</p> <ul> <li>Decision Trees</li> <li>Probabilistic models</li> <li>Linear models</li> <li>Non-linear models</li> </ul> <p>In the case of non-linear data, there are different methods to model this.</p> <ol> <li>MLP : achieve non-linearlity by combining perceptrons(linear models)</li> <li>SVM : supervised machine learning algorithm used for classification and regression tasks.</li> <li>SVC :</li> </ol> <h5 id="svm">SVM</h5> <p>Support Vector Machine (SVM) is a supervised machine learning algorithm used for classification and regression tasks. The key idea is to find the best hyperplane that separates data points into different classes. In an ideal case, this hyperplane maximizes the margin between data points of different classes.</p> <ul> <li>Core Concepts: <ul> <li>The hyperplane is the decision boundary.</li> <li>SVM focuses on data points (support vectors) near the decision boundary that influence its position.</li> <li>The algorithm uses kernels to transform data into higher-dimensional spaces when it is not linearly separable in the original space.</li> </ul> </li> <li>Applications: Image classification, text categorization, and other binary/multi-class problems.</li> <li>Pros: <ul> <li>Effective for high-dimensional spaces.</li> <li>Works well with a clear margin of separation.</li> </ul> </li> <li>Cons: <ul> <li>Computationally expensive for large datasets.</li> <li>Sensitive to the choice of kernel and hyperparameters.</li> </ul> </li> </ul> <h6 id="rbf-kernel">RBF Kernel</h6> <p>The RBF kernel, also known as the Gaussian kernel, is one of the most commonly used kernels in SVM. It is a non-linear kernel that maps data points into a higher-dimensional space where a linear hyperplane can effectively separate them.</p> <p>Characteristics:</p> <ul> <li>Non-linearity: It can model complex relationships in the data.</li> <li>Local influence: Points that are closer to each other have a higher similarity, and their influence decreases exponentially with distance</li> <li> <p>Scalability: Effective for problems where the decision boundary is not linear.</p> </li> <li>Pros: <ul> <li>Handles non-linearly separable data well.</li> <li>Requires fewer hyperparameters compared to other kernels.</li> </ul> </li> <li>Cons: <ul> <li>γ must be carefully tuned; poor tuning can lead to overfitting or underfitting.</li> </ul> </li> </ul> <h6 id="polynomial-kernel">Polynomial Kernel</h6> <p>The Polynomial kernel is another non-linear kernel used in SVM. It computes the similarity between two data points as a polynomial function of their inner product in the input space.</p> <p>Characteristics:</p> <ul> <li>Non-linearity: Maps the input space to a higher-dimensional space defined by polynomial terms.</li> <li>Flexibility: The degree \(d\) controls the complexity of the decision boundary.</li> <li>Global influence: Unlike the RBF kernel, it considers global features of the data.</li> <li>Pros: <ul> <li>Can model non-linear relationships with adjustable complexity via \(d\)</li> <li>Effective for datasets where classes are distinguishable by polynomial decision boundaries.</li> </ul> </li> <li>Cons: <ul> <li>More sensitive to feature scaling than the RBF kernel.</li> <li>Higher degrees can lead to overfitting.</li> </ul> </li> </ul> <h5 id="svc">SVC</h5> <ul> <li> <p>SVC stands for Support Vector Classifier and is the implementation of SVM for classification tasks in libraries like scikit-learn.</p> </li> <li>Key Differences Between SVM and SVC: SVM is the broader concept that encompasses both classification and regression tasks (e.g., SVM for regression is called SVR).</li> <li>SVC is specifically the classification implementation of SVM in scikit-learn.</li> <li>Features of SVC: <ul> <li>It supports linear and non-linear kernels like polynomial, RBF (Radial Basis Function), and sigmoid.</li> <li>Provides hyperparameters like C (regularization strength) and gamma (kernel coefficient) for tuning the model.</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="study"/><category term="ML"/><summary type="html"><![CDATA[Table of Contents]]></summary></entry><entry><title type="html">(KOR) VsCode Shortcut Keys[MacOS]</title><link href="https://joohunhyun.github.io/blog/2024/VsCode-Shortcut-Keys/" rel="alternate" type="text/html" title="(KOR) VsCode Shortcut Keys[MacOS]"/><published>2024-12-13T00:00:00+00:00</published><updated>2024-12-13T00:00:00+00:00</updated><id>https://joohunhyun.github.io/blog/2024/VsCode-Shortcut-Keys</id><content type="html" xml:base="https://joohunhyun.github.io/blog/2024/VsCode-Shortcut-Keys/"><![CDATA[<p>💡익숙해진 단축키는 문서에서 삭제</p> <p>💡원본은 .md 파일에 존안</p> <hr/> <p><strong>Table of contents</strong></p> <ul> <li><a href="#vscode-shortcuts">VScode Shortcuts</a></li> <li><a href="#vscode-git-status">VSCode git status</a></li> </ul> <p><br/></p> <h4 id="vscode-shortcuts">VScode Shortcuts</h4> <table> <thead> <tr> <th>Action</th> <th>Shortcut</th> </tr> </thead> <tbody> <tr> <td><strong>General</strong></td> <td> </td> </tr> <tr> <td>Open Command Palette</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + P</code></td> </tr> <tr> <td>Open Settings</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ,</code></td> </tr> <tr> <td>Open Keyboard Shortcuts</td> <td><code class="language-plaintext highlighter-rouge">⌘ + K ⌘ + S</code></td> </tr> <tr> <td>Open Extensions View</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + X</code></td> </tr> <tr> <td>Show Integrated Terminal</td> <td><code class="language-plaintext highlighter-rouge">⌃ + \</code></td> </tr> <tr> <td>Close Window</td> <td><code class="language-plaintext highlighter-rouge">⌘ + W</code></td> </tr> <tr> <td>Quit VSCode</td> <td><code class="language-plaintext highlighter-rouge">⌘ + Q</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>GitHub Copilot</strong></td> <td> </td> </tr> <tr> <td>Accept Suggestion</td> <td><code class="language-plaintext highlighter-rouge">Tab</code></td> </tr> <tr> <td>Next Suggestion</td> <td><code class="language-plaintext highlighter-rouge">Option(Alt) + ]</code></td> </tr> <tr> <td>Previous Suggestion</td> <td><code class="language-plaintext highlighter-rouge">Option(Alt) + [</code></td> </tr> <tr> <td>Show Suggestions</td> <td><code class="language-plaintext highlighter-rouge">Ctrl + Enter</code></td> </tr> <tr> <td>Approve Suggestion</td> <td><code class="language-plaintext highlighter-rouge">Cmd + ←</code> or <code class="language-plaintext highlighter-rouge">Cmd + →</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>File Management</strong></td> <td> </td> </tr> <tr> <td>Open File</td> <td><code class="language-plaintext highlighter-rouge">⌘ + O</code></td> </tr> <tr> <td>Save File</td> <td><code class="language-plaintext highlighter-rouge">⌘ + S</code></td> </tr> <tr> <td>Save All Files</td> <td><code class="language-plaintext highlighter-rouge">⌥ + ⌘ + S</code></td> </tr> <tr> <td>Close Editor</td> <td><code class="language-plaintext highlighter-rouge">⌘ + W</code></td> </tr> <tr> <td>Reopen Closed Editor</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + T</code></td> </tr> <tr> <td>New File</td> <td><code class="language-plaintext highlighter-rouge">⌘ + N</code></td> </tr> <tr> <td>Open Recent Files</td> <td><code class="language-plaintext highlighter-rouge">⌘ + R</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Editing</strong></td> <td> </td> </tr> <tr> <td>Cut Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + X</code></td> </tr> <tr> <td>Copy Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + C</code></td> </tr> <tr> <td>Paste</td> <td><code class="language-plaintext highlighter-rouge">⌘ + V</code></td> </tr> <tr> <td>Delete Line</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + K</code></td> </tr> <tr> <td>Duplicate Line</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌥ + ↓</code> or <code class="language-plaintext highlighter-rouge">⇧ + ⌥ + ↑</code></td> </tr> <tr> <td>Move Line Up/Down</td> <td><code class="language-plaintext highlighter-rouge">⌥ + ↑</code> or <code class="language-plaintext highlighter-rouge">⌥ + ↓</code></td> </tr> <tr> <td>Indent Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ]</code></td> </tr> <tr> <td>Outdent Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + [</code></td> </tr> <tr> <td>Comment Line</td> <td><code class="language-plaintext highlighter-rouge">⌘ + /</code></td> </tr> <tr> <td>Add Multi-Cursor</td> <td><code class="language-plaintext highlighter-rouge">⌥ + Click</code></td> </tr> <tr> <td>Select All Occurrences</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ⇧ + L</code></td> </tr> <tr> <td>Expand Selection</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌥ + →</code></td> </tr> <tr> <td>Shrink Selection</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌥ + ←</code></td> </tr> <tr> <td>Format Document</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌥ + F</code></td> </tr> <tr> <td>Go to Matching Bracket</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + \</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Navigation</strong></td> <td> </td> </tr> <tr> <td>Go to File</td> <td><code class="language-plaintext highlighter-rouge">⌘ + P</code></td> </tr> <tr> <td>Go to Line</td> <td><code class="language-plaintext highlighter-rouge">⌃ + G</code></td> </tr> <tr> <td>Go to Definition</td> <td><code class="language-plaintext highlighter-rouge">F12</code></td> </tr> <tr> <td>Go to Implementation</td> <td><code class="language-plaintext highlighter-rouge">⌘ + F12</code></td> </tr> <tr> <td>Show References</td> <td><code class="language-plaintext highlighter-rouge">⇧ + F12</code></td> </tr> <tr> <td>Navigate Back</td> <td><code class="language-plaintext highlighter-rouge">⌃ + -</code></td> </tr> <tr> <td>Navigate Forward</td> <td><code class="language-plaintext highlighter-rouge">⌃ + ⇧ + -</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Search and Replace</strong></td> <td> </td> </tr> <tr> <td>Find</td> <td><code class="language-plaintext highlighter-rouge">⌘ + F</code></td> </tr> <tr> <td>Find in Files</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + F</code></td> </tr> <tr> <td>Replace</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ⌥ + F</code></td> </tr> <tr> <td>Replace in Files</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + H</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Debugging</strong></td> <td> </td> </tr> <tr> <td>Start/Continue Debugging</td> <td><code class="language-plaintext highlighter-rouge">F5</code></td> </tr> <tr> <td>Step Over</td> <td><code class="language-plaintext highlighter-rouge">F10</code></td> </tr> <tr> <td>Step Into</td> <td><code class="language-plaintext highlighter-rouge">F11</code></td> </tr> <tr> <td>Step Out</td> <td><code class="language-plaintext highlighter-rouge">⇧ + F11</code></td> </tr> <tr> <td>Restart Debugging</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + F5</code></td> </tr> <tr> <td>Stop Debugging</td> <td><code class="language-plaintext highlighter-rouge">⇧ + F5</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Terminal</strong></td> <td> </td> </tr> <tr> <td>Create New Terminal</td> <td><code class="language-plaintext highlighter-rouge">⌘ + ⇧ + </code>`</td> </tr> <tr> <td>Split Terminal</td> <td><code class="language-plaintext highlighter-rouge">⌘ + \</code>`</td> </tr> <tr> <td>Kill Terminal</td> <td><code class="language-plaintext highlighter-rouge">⌘ + K</code> (inside terminal)</td> </tr> <tr> <td>Navigate Terminals</td> <td><code class="language-plaintext highlighter-rouge">⌃ + ←</code> or <code class="language-plaintext highlighter-rouge">⌃ + →</code></td> </tr> <tr> <td> </td> <td> </td> </tr> <tr> <td><strong>Version Control</strong></td> <td> </td> </tr> <tr> <td>Open Source Control</td> <td><code class="language-plaintext highlighter-rouge">⇧ + ⌘ + G</code></td> </tr> <tr> <td>Commit Changes</td> <td><code class="language-plaintext highlighter-rouge">⌘ + Enter</code> (in source control)</td> </tr> </tbody> </table> <p><br/></p> <h4 id="vscode-git-status">VSCode git status</h4> <table> <thead> <tr> <th>Code</th> <th>Status</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>A</td> <td>Added</td> <td>This is a new file that has been added to the repository</td> </tr> <tr> <td>M</td> <td>Modified</td> <td>An existing file has been changed</td> </tr> <tr> <td>D</td> <td>Deleted</td> <td>A file has been deleted</td> </tr> <tr> <td>U</td> <td>Untracked</td> <td>The file is new or has been changed but has not been added to the repository yet</td> </tr> <tr> <td>C</td> <td>Conflict</td> <td>There is a conflict in the file</td> </tr> <tr> <td>R</td> <td>Renamed</td> <td>The file has been renamed</td> </tr> <tr> <td>S</td> <td>Submodule</td> <td>In repository exists another subrepository</td> </tr> <tr> <td>T</td> <td>Typechange</td> <td>The file changed from symlink to regular file, or vice versa</td> </tr> </tbody> </table> ]]></content><author><name></name></author><category term="study"/><category term="tools"/><summary type="html"><![CDATA[💡익숙해진 단축키는 문서에서 삭제]]></summary></entry></feed>