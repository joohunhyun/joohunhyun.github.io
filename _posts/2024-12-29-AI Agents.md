---
layout: post
title: (KOR) AI Agents 스터디 자료
date: 2024-12-29
description:
tags: NLP 
categories: study
featured: false
toc:  
  sidebar: left
---

**TOC**
- [1. AI Agents : Introduction](#1-ai-agents--introduction)
- [2. AI Agents : Methodology](#2-ai-agents--methodology)
  - [2.1 동작 순서](#21-동작-순서)
  - [2.2 동작 원리](#22-동작-원리)
  - [2.3 상호작용](#23-상호작용)
  - [2.4 AI Agent 종류](#24-ai-agent-종류)
- [3. 스터디 자료 정리](#3-스터디-자료-정리)
  - [3.1 Agentic AI vs Generative AI](#31-agentic-ai-vs-generative-ai)
  - [3.2 Agentic AI: Building Autonomous Systems from Scratch](#32-agentic-ai-building-autonomous-systems-from-scratch)
  - [3.3 THE LANDSCAPE OF EMERGING AI AGENT ARCHITECTURES FOR REASONING, PLANNING, AND TOOL CALLING: A SURVEY](#33-the-landscape-of-emerging-ai-agent-architectures-for-reasoning-planning-and-tool-calling-a-survey)
  - [3.4 AI Agents vs Agentic AI : What’s the Difference and Why Does It Matter?](#34-ai-agents-vs-agentic-ai--whats-the-difference-and-why-does-it-matter)
  - [3.5 The Emergence of AI Agent Architecture](#35-the-emergence-of-ai-agent-architecture)
  - [3.6 Best Multi-AI Agent Frameworks](#36-best-multi-ai-agent-frameworks)
  - [3.7 Patterns for Building Production Grade Agentic AI using Multi-Agent Systems , Patterns 1–5](#37-patterns-for-building-production-grade-agentic-ai-using-multi-agent-systems--patterns-15)
  - [3.8 Anatomy of Agentic AI](#38-anatomy-of-agentic-ai)
- [4. External Research](#4-external-research)
  - [Anthropic - Builidng Effective Agents 정리](#anthropic---builidng-effective-agents-정리)
  - [보안 이슈](#보안-이슈)
- [5. 프레임워크 사용기](#5-프레임워크-사용기)
  - [CrewAI - AI agent 개발용](#crewai---ai-agent-개발용)


---

### 1. AI Agents : Introduction

기존의 LLM이 성능을 높히기 위해 사용한 기술들:

- RAG
- Chain of thought
- Few-shot prompting
- Vector serach
- Memory


AI agent는 사람의 개입없이 AI가 task 수행을 위한 모든 역할을 수행하는 agent를 의미한다. AI agent는 사용자의 프롬프트 입력 없이, 하위 task를 설계하고, 검토하고, 수행하는 과정(**Self-Prompting**)을 반복하는 특징을 가진다. 변하는 상황에 따라 접근 방식을 스스로 조정하며 목표 달성을 위한 전략을 수립하고 실행한다.

AI agent의 요건
1. 작업 실행을 계획하고 사용 가능한 도구를 활용하여 작업을 자율적으로 수행하는 시스템
2. 사용자를 대신해 자율적으로 작업을 수행할 수 있는 프로그램
3. 인간의 지속적인 입력 필요없이 스스로 생각하고, 결정하고, 행동함


예를 들어, 사용자의 프롬프트가 "**200만원 예산 내로 3박4일 일정으로 일본 여행을 가고 싶어.**"일 경우, AI Agent는:
- 사용자의 캘린더앱을 확인해 여행 일정 추천
- skyscanner를 통해 여행 일정에 맞는 항공권 추천
- 숙박 사이트를 통해 예산에 맞는 호텔 검색
- 관광지 웹사이트를 확인해 관광지 운영 시간 등을 확인


<br>

### 2. AI Agents : Methodology

#### 2.1 동작 순서

{% include figure.liquid loading="eager" path="assets/img/16.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}

1. environment를 파악하고
2. 수집한 정보를 활용하여
3. 목표 달성을 위한 계획을 세우고
4. 이를 실행함


#### 2.2 동작 원리

{% include figure.liquid loading="eager" path="assets/img/17.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}

1. observations를 통해 environment를 파악하고
2. past experiences, abilities, goals/preferencees/prior knowledge를 바탕으로 actions 수행
3. 1,2 번 (반복)

용어 정리
- environment : agent가 작동하는 영역/도메인 (여행 계획 수립 agent예시의 경우, 사용자의 캘린더, 위치정보, 언어설정, 등)
- abilities/prior knowledge : 모델이 데이터를 통해 이미 학습한 지식
- goals/preferences : 사용자의 요청의 목적, 수행할 task들을 agent가 스스로 판단
- observations : 주어진 환경에 대해 수집한 정보
- past experiences : Agent가 가진 과거의 경험


#### 2.3 상호작용

{% include figure.liquid loading="eager" path="assets/img/18.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}


#### 2.4 AI Agent 종류

단순 반응형 에이전트 (Reactive Agent)

- **특징**: 과거의 데이터를 저장하지 않고, 현재 환경에서 관찰한 정보를 바탕으로 즉각적인 반응을 보이는 에이전트  
- **예시**:  
  - 자동문 시스템: 센서를 통해 사람의 존재를 인식하고 문을 여는 역할 수행  
  - 온도 조절기: 현재 온도를 기준으로 난방 또는 냉방을 수행  


상태 기반 에이전트 (Model-Based Agent)

- **특징**: 현재 상태와 과거 상태를 내부적으로 저장하여 의사결정을 수행하며, 환경에 대한 모델을 사용하여 복잡한 작업을 처리할 수 있음  
- **예시**:  
  - 네비게이션 시스템: 목적지와 현재 위치를 바탕으로 최적의 경로를 계산  


목표 지향형 에이전트 (Goal-Based Agent)

- **특징**: 목표 중심으로 작동하며, 현재 상태와 목표 상태의 차이를 줄이기 위한 계획을 수립함  
- **예시**:  
  - 로봇 청소기: 방의 청소가 필요한 위치를 탐지하고 효율적으로 움직임  
  - 물류 로봇: 특정 지점에 물건을 운반하는 작업을 수행  


유틸리티 기반 에이전트 (Utility-Based Agent)

- **특징**: 목표 달성뿐만 아니라 목표 달성의 "질"을 고려하여 유틸리티 함수(만족도, 이익 등)를 기반으로 최적의 선택을 수행함  
- **예시**:  
  - 자율주행 차량: 안전, 시간, 연료 효율성을 동시에 고려하여 경로 선택  
  - 추천 시스템: 사용자 선호도에 따라 최적의 옵션을 추천  


학습 에이전트 (Learning Agent)

- **특징**: 경험을 통해 학습하고 시간이 지남에 따라 성능을 점진적으로 개선하며, 학습 요소, 성능 요소, 비평 요소, 문제 생성기를 포함한 구성 요소로 작동  
- **예시**:  
  - AlphaGo: 체스 또는 바둑과 같은 게임을 스스로 학습하고 개선  
  - 챗봇: 사용자와의 대화 기록을 기반으로 점진적으로 대화 능력 향상  


다중 에이전트 시스템 (Multi-Agent System)

- **특징**: 여러 에이전트가 협력하거나 경쟁하며 목표를 달성하는 시스템으로, 각 에이전트는 독립적으로 작동하며 상호작용을 통해 복잡한 문제를 해결함  
- **예시**:  
  - 스마트 그리드: 전력 분배를 최적화하는 시스템  
  - 온라인 게임 AI: 다수의 캐릭터 간 협력 및 경쟁 (예: Pacman)  


하이브리드 에이전트 (Hybrid Agent)

- **특징**: 위에서 언급된 여러 종류의 에이전트를 조합하여 설계된 시스템으로, 복잡한 문제 해결을 위해 다양한 접근 방식을 사용함  
- **예시**:  
  - 자율주행 차량: 감지(단순 반응형)와 경로 계획(목표 지향형)을 동시에 수행  
  - 인공지능 비서(Siri, Alexa): 학습 및 목표 지향형 기능을 결합  

<br>

### 3. 스터디 자료 정리

#### 3.1 Agentic AI vs Generative AI

TL;DR : **Agentic Workflow**는 Zero-shot보다 훨씬 더 높은 정확도를 보인다.

- **LLMs**: 입력된 패턴에 반응하며 작동하는 시스템  
- **Agentic AI**: 자율성, 목표 지향적 행동, 학습 및 환경 인식을 통해 지속적인 문제 해결 능력이 필요한 문제도 해결 가능
- **Agentic AI의 특징**
    - autonomy
    - goal directed behavior
    - learning from actions and experiences
    - Environmental Perception : AI must understand its environment

**case study : Agentic Workflow의 우수성**

Andrew Ng shared a case study to highlight the power of the Agentic Workflow in coding tasks. **HumanEval coding benchmark**를 벤치마크로 사용해 다음과 같은 실험을 진행했다.

- **Zero-shot prompting**: 추가 가이던스(prompting) 없이 문제를 해결하도록 요청하는 방법
  - GPT-3.5: 48% 정확도  
  - GPT-4: 67% 정확도  
- **Agentic Workflow**: 작업을 이해, 코딩, 테스트 및 디버깅 등의 단계로 나누어 AI가 반복적으로 개선하도록 설계  
  - GPT-3.5가 GPT-4보다 우수한 성과를 보임


#### 3.2 Agentic AI: Building Autonomous Systems from Scratch

**MAS 예시 소스코드**: [GitHub 코드](https://github.com/zaai-ai/lab)

Agentic AI의 필수 구성 요소 (클래스 2개를 작성해야 함)

1. **Agent**
   - **LLM**: GPT-4 등  
   - **Role**: 정보 처리, 데이터베이스 조회, 상호작용 조정  
   - **Backstory**: 현재 환경에 대한 사전 지식  
   - **Goal**: 에이전트의 목표  
2. **Task**
   - **Description**: 수행할 작업과 목표 설명  
   - **Output**: 출력 형식 정의 (예: 텍스트, JSON, HTML)  



#### 3.3 THE LANDSCAPE OF EMERGING AI AGENT ARCHITECTURES FOR REASONING, PLANNING, AND TOOL CALLING: A SURVEY




#### 3.4 AI Agents vs Agentic AI : What’s the Difference and Why Does It Matter?

TL;DR : **Agentic AI와 AI Agents의 차이점**에 대한 글

AI Agents vs Agenic AI
- **자율성**: Agentic AI는 독립적이고 지속적인 의사결정 가능  
- **상호작용**: AI Agents는 주로 사용자의 명령에 따라 작동 

예시
- **Agentic AI**: 자율주행 자동차 (테슬라 FSD), 아마존 창고 로봇  
- **AI Agents**: 고객 서비스 챗봇, GitHub Copilot

{% include figure.liquid loading="eager" path="assets/img/19.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}


#### 3.5 The Emergence of AI Agent Architecture

TL;DR : LAM, Model Orchestration, Vision-지원 언어 모델, function calling을 사용하면, 에이전트는 문제 해결, 디지털 환경 (digital landscape) 탐색, 및 자율적인 학습 능력을 가질 수 있게 된다.

주요 개념
- **Retrieval-Augmented Generation (RAG)**: 작은 언어 모델(SLM)을 보완하여 큰 언어 모델과 유사한 성능 제공  
- **Model Orchestration**: SLM을 결합하여 특정 작업을 지원함
- **Function calling** : 대형 언어 모델(LLM)의 기능을 텍스트 생성 기증을 넘어 확장성을 제공함
- **LAM(대형 행동 모델)** : 단순한 언어 생성을 넘어 실제 있을 법한 시나리오에서 의미 있는 행동을 수행할 수 있도록 설계되었다. 이를 통해 AI는 데이터베이스 쿼리나 API 호출과 같은 외부 프로세스를 실행할 수 있다.


#### 3.6 Best Multi-AI Agent Frameworks

TL;DR : 멀티 AI 에이전트를 개발할 시 사용할 프레임워크를 추천하는 글

**추천 프레임워크**

- **소프트웨어 개발**: AutoGen (Microsoft)
  - 코드 생성 및 복잡한 다중 에이전트 코딩 워크플로우에 가장 적합합니다.
- **초보자에게 추천**: OpenAI Swarm, CrewAI
  - 사용자 친화적
  - 복잡한 설정 요구 없이 다중 에이전트 AI에 적합함 
- **복잡한 작업에 최적화**: LangGraph
  - 높은 flexibility 제공하며, 고급 사용자를 위해 설계되어 에이전트의 커스텀 로직과 orchestration을 허용
- **오픈소스 LLM**: LangGraph
  - 다양한 API를 지원
- **저비용 개발용**: Magentic-One
  - 사전 패키지 설정과 generalist approach를 제공하여 초기 비용을 절감할 수 있다. Swarm과 CrewAI라는 옵션도 있음.
- **즉시 적용 가능한 프레임워크**: CrewAI
  - 환경설정이 빠르고
  - 사용이 직관적이며
  - 신속한 에이전트 생성이 필요할 경우 적합함
  - Swarm과 Magentic-One도 좋으나 커뮤니티 형성이 덜 되어있음


#### 3.7 Patterns for Building Production Grade Agentic AI using Multi-Agent Systems , Patterns 1–5


#### 3.8 Anatomy of Agentic AI

TL;DR **Agentic AI 아키텍처**와 이를 구현할 때 고려해야 할 점을 다룬다.

아키텍처 예시 : 
{% include figure.liquid loading="eager" path="assets/img/20.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}

개발 시 고려할 점 :

- **모듈화와 확장성**: 복잡한 작업을 처리할 수 있도록 설계해야 함
- **적응성**: 환경에 따라 학습 및 행동을 개선할 수 있어야 함
- **멀티모달 상호작용**: 디지털 및 물리적 환경과 상호작용이 되도록 개발해야 함
- **협력**: 공유 메모리를 활용한 에이전트 간 협력

### 4. External Research


#### Anthropic - Builidng Effective Agents 정리

클라우드에서는 workflow와 agent를 구분한다. **Workflow**란 LLM과 tools가 predefined code path를 통해 orchestrated 되는 것을 의미하는 반면, **Agents**는 LLM이 동적으로 자신들의 프로세스와 tool 사용을 정의하고, task 수행을 자율적으로 컨트롤하는 시스템을 의미한다. Agent는 flexibility나 모델-주도-의사결정 과정이 필요한 경우에 사용하고, workflow는 반복적이거나 잘 정의된(well-defined) task를 수행할 때 용의한 시스템이다. 에이전트를 개발할 때 있어서, LangGraph, Rivet, Vellum 등의 프레임워크가 있으나, 이런 프레임워크는 복잡한 layer들을 추가하여 디버깅을 까다롭게 한다. 그럼으로, 클라우드는 LLM API를 직접 사용하여 agentic system을 개발하는 것을 권장한다. 코드 examples는 여기서 확인해볼 수 있다 -> [클라우드의 cookbook](https://github.com/anthropics/anthropic-cookbook/tree/main/patterns/agents).



**Prompt Chaining**

Prompt Chaining 방식은 task가 여러 subtask로 깔끔하게 떨어지는 경우에 사용하는 것을 권장한다. 이 방식의 경우 Tradeoff가 발생하게 되는데, latency<->accuracy의 tradeoff 관계가 형성된다.

{% include figure.liquid loading="eager" path="assets/img/22.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}

**Routing**

Routing 방식은 input을 분류하여 다음 작업으로 전달해주는 과정을 의미한다. CS센터 챗봇 개발에 용의한 아키텍처이다. Input(고객 문의) -> 일반 문의/제품 문의/환불 요청 3중 1택 -> Output(챗봇 전달 내용)


{% include figure.liquid loading="eager" path="assets/img/23.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}

**Orchestrator-Workers**

Orchestrator-Workers 방식에서는 Central LLM이 task를 동적으로 세분화하여 worker LLM에 이를 넘겨주고 그 결과를 종합한다. 해당 방식은 최종 goal의 하위 task들을 예측할 수 없는 복잡한 작업들에 적합하다. 하위 작업은 미리 정의되지 않고, 특정 입력에 따라 orchestrator가 이를 결정한다.

{% include figure.liquid loading="eager" path="assets/img/24.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}


**Evaluator-optimizer**

Evaluator-optimizer 방식에서는 LLM call Generator가 응답을 생성하고 이를 LLM Call Evaluator가 받아 Accept하거나, Reject를 할 경우, 평가와 피드백을 제공한다.
반복적으로 수행하는 작업을 한다. LLM Call Evaluator가 응답을 Accept할 떄까지 Loop이 생성된다(exit condition). 해당 방식은 명확한 평가 기준이 있고 반복적인 개선 작업을 통해 측정 가능한 가치가 있을 경우 효과적이다. 예를 들어 웹 서핑을 통해 정보를 수집하기 위해 여러 차례의 검색과 분석이 필요한 복잡한 검색 작업의 경우, Evaluator가 추가 검색이 필요한지 여부를 결정해 검색 정확도를 높힐 수 있다.

{% include figure.liquid loading="eager" path="assets/img/25.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}


**Agents**

Agent 방식은 요즘 각광받고 있는 워크플로우이다. Agent의 워크플로우를 요약하자면 다음과 같다. Tools 설계 시  고려할 점 : 에이전트는 tools와 feedback loop에 의존하므로, tools와 관련된 코드를 명확하고 신중하게 설계하는 것이 중요합니다. 또한, Agent의 자율적인 특성은 높은 토큰 비용과 오류의 가능성이 높아짐을 의미한다. 적절한 exit condition를 **무조건** 구현하고, 샌드박스 환경에서 광범위한 테스트를 사전에 수행할 것을 권장함.


1. Input: 에이전트가 사용자의 명령, 혹은 사용자와의 대화(Q&A)를 통해 작업을 시작하고, 작업을 명확히 정의함.
2. 계획 수립 단계: 하위 작업들이 명확히 정의되면, 에이전트들이 계획을 세우고 자율적으로 작업을 진행합니다.
3. 실행 단계: 에이전트는 각 단계에서 환경으로부터 "정확한 정보(ground truth)"를 도출해 진행 상황을 평가합니다.
4. 사용자와의 상호작용(Optional): 에이전트는 중간 체크포인트나 장애물에 직면했을 때 작동을 멈추고, 사용자로부터 추가 피드백이나 판단을 요청합니다.
5. Completion 단계: 작업이 성공적으로 완료되거나, 사전에 정의된 exit condition이 충족되면 작동울 멈춘다.


{% include figure.liquid loading="eager" path="assets/img/26.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}

다음 자료는 coding Agent의 high-level 워크플로우입니다.

{% include figure.liquid loading="eager" path="assets/img/27.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}

**최종 설계**
위에 설명한 워크플로우들을 목적에 맞게 결합할 수 있다. 모든 LLM 기능 개발과 마찬가지로, 성공의 비결은:

1. 구현
2. 성능 측정
  
1번과 2번을 반복하는 것이다. 한 가지를 더 강조하자면, 성능이 확실히 개선되는 경우에만 기능을 추가하는 것을 권장한다.


[출처](https://www.anthropic.com/research/building-effective-agents)



#### 보안 이슈

AI가 컴퓨터 화면을 읽게 하여 컴퓨터를 조작하는 자율성 높은 Agentic AI 개발 시 보안 문제가 야기된다. prompt injection는 특정 웝사이트에 어떤 prompt(listener 등)를 끼워넣는 행위를 의미하는데, agentic AI가 이를 실행해버리는 경우도 있다.


### 5. 프레임워크 사용기

#### CrewAI - AI agent 개발용

[official docs](https://docs.crewai.com/concepts/flows)


**작동방식**

{% include figure.liquid loading="eager" path="assets/img/21.jpg" class="img-fluid rounded z-depth-1" zoomable=true %}



**구성 요소**

| 구성 요소    | 설명                          | 주요 특징                                             |
|-------------|------------------------------|-----------------------------------------------------|
| **Crew**    | 최상위 조직                    | • AI 에이전트 팀 관리<br>• 워크플로우 감독<br>• 협업 보장<br>• 결과 제공 |
| **AI Agents** | 특화된 팀원                   | • 특정 역할 수행 (연구자, 작가 등)<br>• 지정된 도구 사용<br>• 작업 위임 가능<br>• 자율적 의사결정 |
| **Process** | 워크플로우 관리 시스템         | • 협업 패턴 정의<br>• 작업 할당 관리<br>• 상호작용 관리<br>• 효율적 실행 보장 |
| **Tasks**   | 개별 작업                     | • 명확한 목표 설정<br>• 특정 도구 사용<br>• 전체 프로세스에 기여<br>• 실행 가능한 결과 생산 |

<br>

**연동 방식**

1. **Crew**가 전체 운영을 조직화합니다.
2. **AI Agents**는 자신들이 특화된 작업을 수행합니다.  
3. **Process**는 원활한 협업을 보장합니다.
4. 최종 목표 달성을 위해 **Tasks**를 수행합니다.